Grammar:

Rule 0     S' -> program
Rule 1     program -> functions
Rule 2     functions -> <empty>
Rule 3     functions -> function functions
Rule 4     function -> ID LPAREN formal_params RPAREN COLON type scope
Rule 5     formal_params -> <empty>
Rule 6     formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
Rule 7     formal_params -> ID COLON type multi_formal_params
Rule 8     multi_formal_params -> <empty>
Rule 9     multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
Rule 10    multi_formal_params -> COMMA ID COLON type multi_formal_params
Rule 11    function_call -> ID LPAREN actual_params RPAREN
Rule 12    actual_params -> <empty>
Rule 13    actual_params -> expression multi_actual_params
Rule 14    multi_actual_params -> <empty>
Rule 15    multi_actual_params -> COMMA expression multi_actual_params
Rule 16    scope -> LBRACE new_scope statements pop_scope RBRACE
Rule 17    new_scope -> <empty>
Rule 18    pop_scope -> <empty>
Rule 19    statements -> <empty>
Rule 20    statements -> statement statements
Rule 21    statement -> END
Rule 22    statement -> if_statement
Rule 23    statement -> for_statement
Rule 24    statement -> while_statement
Rule 25    statement -> scope
Rule 26    statement -> array_assignment END
Rule 27    statement -> scalar_assignment END
Rule 28    statement -> array_declaration_init END
Rule 29    statement -> scalar_declaration_init END
Rule 30    statement -> array_declaration END
Rule 31    statement -> scalar_declaration END
Rule 32    statement -> expression END
Rule 33    for_component -> <empty>
Rule 34    for_component -> expression
Rule 35    for_component -> array_declaration_init
Rule 36    for_component -> scalar_declaration_init
Rule 37    for_component -> array_assignment
Rule 38    for_component -> scalar_assignment
Rule 39    for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope
Rule 40    while_statement -> WHILE LPAREN expression RPAREN scope
Rule 41    if_statement -> IF LPAREN expression RPAREN scope else_statement
Rule 42    else_statement -> <empty>
Rule 43    else_statement -> ELSE if_statement
Rule 44    else_statement -> ELSE scope
Rule 45    scalar_declaration -> DECLARE ID COLON type
Rule 46    array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
Rule 47    scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression
Rule 48    array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
Rule 49    scalar_assignment -> ID ASSIGN expression
Rule 50    array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
Rule 51    expression -> comparison_layer
Rule 52    expression -> expression OR comparison_layer
Rule 53    expression -> expression AND comparison_layer
Rule 54    comparison_layer -> arithmetic_layer
Rule 55    comparison_layer -> comparison_layer COMPARATOR arithmetic_layer
Rule 56    arithmetic_layer -> term
Rule 57    arithmetic_layer -> arithmetic_layer MINUS term
Rule 58    arithmetic_layer -> arithmetic_layer PLUS term
Rule 59    term -> factor
Rule 60    term -> term DIVISION factor
Rule 61    term -> term MULTIPLICATION factor
Rule 62    factor -> ID
Rule 63    factor -> ID LSBRACKET arithmetic_layer RSBRACKET
Rule 64    factor -> value
Rule 65    factor -> LPAREN expression RPAREN
Rule 66    factor -> function_call
Rule 67    type -> ABYSS_TYPE
Rule 68    type -> BOOL_TYPE
Rule 69    type -> STRING_TYPE
Rule 70    type -> CHAR_TYPE
Rule 71    type -> FLOAT_TYPE
Rule 72    type -> UNSIGNED_TYPE
Rule 73    type -> SIGNED_TYPE
Rule 74    value -> STRING_VALUE
Rule 75    value -> CHAR_VALUE
Rule 76    value -> BOOL_VALUE
Rule 77    value -> FLOAT_VALUE
Rule 78    value -> INTEGRAL_VALUE

Unused terminals:

    INSERTION
    EXTRACTION

Terminals, with rules where they appear:

ABYSS_TYPE           : 67
AND                  : 53
ASSIGN               : 47 48 49 50
BOOL_TYPE            : 68
BOOL_VALUE           : 76
CHAR_TYPE            : 70
CHAR_VALUE           : 75
COLON                : 4 6 7 9 10 45 46 47 48
COMMA                : 9 10 15
COMPARATOR           : 55
DECLARE              : 45 46 47 48
DIVISION             : 60
ELSE                 : 43 44
END                  : 21 26 27 28 29 30 31 32 39 39
EXTRACTION           : 
FLOAT_TYPE           : 71
FLOAT_VALUE          : 77
FOR                  : 39
ID                   : 4 6 7 9 10 11 45 46 47 48 49 50 62 63
IF                   : 41
INSERTION            : 
INTEGRAL_VALUE       : 6 9 46 48 78
LBRACE               : 16
LPAREN               : 4 11 39 40 41 65
LSBRACKET            : 6 9 46 48 50 63
MINUS                : 57
MULTIPLICATION       : 61
OR                   : 52
PLUS                 : 58
RBRACE               : 16
RPAREN               : 4 11 39 40 41 65
RSBRACKET            : 6 9 46 48 50 63
SIGNED_TYPE          : 73
STRING_TYPE          : 69
STRING_VALUE         : 74
UNSIGNED_TYPE        : 72
WHILE                : 40
error                : 

Nonterminals, with rules where they appear:

actual_params        : 11
arithmetic_layer     : 50 54 55 57 58 63
array_assignment     : 26 37
array_declaration    : 30
array_declaration_init : 28 35
comparison_layer     : 51 52 53 55
else_statement       : 41
expression           : 13 15 32 34 39 40 41 47 48 49 50 52 53 65
factor               : 59 60 61
for_component        : 39 39
for_statement        : 23
formal_params        : 4
function             : 3
function_call        : 66
functions            : 1 3
if_statement         : 22 43
multi_actual_params  : 13 15
multi_formal_params  : 6 7 9 10
new_scope            : 16
pop_scope            : 16
program              : 0
scalar_assignment    : 27 38
scalar_declaration   : 31
scalar_declaration_init : 29 36
scope                : 4 25 39 40 41 44
statement            : 20
statements           : 16 20
term                 : 56 57 58 60 61
type                 : 4 6 7 9 10 45 46 47
value                : 64
while_statement      : 24


state 0

    (0) S' -> . program
    (1) program -> . functions
    (2) functions -> .
    (3) functions -> . function functions
    (4) function -> . ID LPAREN formal_params RPAREN COLON type scope
    $end            reduce using rule 2 (functions -> .)
    ID              shift and go to state 4

    program                        shift and go to state 1
    functions                      shift and go to state 2
    function                       shift and go to state 3

state 1

    (0) S' -> program .


state 2

    (1) program -> functions .
    $end            reduce using rule 1 (program -> functions .)


state 3

    (3) functions -> function . functions
    (2) functions -> .
    (3) functions -> . function functions
    (4) function -> . ID LPAREN formal_params RPAREN COLON type scope
    $end            reduce using rule 2 (functions -> .)
    ID              shift and go to state 4

    function                       shift and go to state 3
    functions                      shift and go to state 5

state 4

    (4) function -> ID . LPAREN formal_params RPAREN COLON type scope
    LPAREN          shift and go to state 6


state 5

    (3) functions -> function functions .
    $end            reduce using rule 3 (functions -> function functions .)


state 6

    (4) function -> ID LPAREN . formal_params RPAREN COLON type scope
    (5) formal_params -> .
    (6) formal_params -> . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (7) formal_params -> . ID COLON type multi_formal_params
    RPAREN          reduce using rule 5 (formal_params -> .)
    ID              shift and go to state 7

    formal_params                  shift and go to state 8

state 7

    (6) formal_params -> ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (7) formal_params -> ID . COLON type multi_formal_params
    LSBRACKET       shift and go to state 9
    COLON           shift and go to state 10


state 8

    (4) function -> ID LPAREN formal_params . RPAREN COLON type scope
    RPAREN          shift and go to state 11


state 9

    (6) formal_params -> ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    INTEGRAL_VALUE  shift and go to state 12


state 10

    (7) formal_params -> ID COLON . type multi_formal_params
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 13

state 11

    (4) function -> ID LPAREN formal_params RPAREN . COLON type scope
    COLON           shift and go to state 21


state 12

    (6) formal_params -> ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 22


state 13

    (7) formal_params -> ID COLON type . multi_formal_params
    (8) multi_formal_params -> .
    (9) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (10) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 8 (multi_formal_params -> .)
    COMMA           shift and go to state 24

    multi_formal_params            shift and go to state 23

state 14

    (67) type -> ABYSS_TYPE .
    COMMA           reduce using rule 67 (type -> ABYSS_TYPE .)
    RPAREN          reduce using rule 67 (type -> ABYSS_TYPE .)
    LBRACE          reduce using rule 67 (type -> ABYSS_TYPE .)
    ASSIGN          reduce using rule 67 (type -> ABYSS_TYPE .)
    END             reduce using rule 67 (type -> ABYSS_TYPE .)


state 15

    (68) type -> BOOL_TYPE .
    COMMA           reduce using rule 68 (type -> BOOL_TYPE .)
    RPAREN          reduce using rule 68 (type -> BOOL_TYPE .)
    LBRACE          reduce using rule 68 (type -> BOOL_TYPE .)
    ASSIGN          reduce using rule 68 (type -> BOOL_TYPE .)
    END             reduce using rule 68 (type -> BOOL_TYPE .)


state 16

    (69) type -> STRING_TYPE .
    COMMA           reduce using rule 69 (type -> STRING_TYPE .)
    RPAREN          reduce using rule 69 (type -> STRING_TYPE .)
    LBRACE          reduce using rule 69 (type -> STRING_TYPE .)
    ASSIGN          reduce using rule 69 (type -> STRING_TYPE .)
    END             reduce using rule 69 (type -> STRING_TYPE .)


state 17

    (70) type -> CHAR_TYPE .
    COMMA           reduce using rule 70 (type -> CHAR_TYPE .)
    RPAREN          reduce using rule 70 (type -> CHAR_TYPE .)
    LBRACE          reduce using rule 70 (type -> CHAR_TYPE .)
    ASSIGN          reduce using rule 70 (type -> CHAR_TYPE .)
    END             reduce using rule 70 (type -> CHAR_TYPE .)


state 18

    (71) type -> FLOAT_TYPE .
    COMMA           reduce using rule 71 (type -> FLOAT_TYPE .)
    RPAREN          reduce using rule 71 (type -> FLOAT_TYPE .)
    LBRACE          reduce using rule 71 (type -> FLOAT_TYPE .)
    ASSIGN          reduce using rule 71 (type -> FLOAT_TYPE .)
    END             reduce using rule 71 (type -> FLOAT_TYPE .)


state 19

    (72) type -> UNSIGNED_TYPE .
    COMMA           reduce using rule 72 (type -> UNSIGNED_TYPE .)
    RPAREN          reduce using rule 72 (type -> UNSIGNED_TYPE .)
    LBRACE          reduce using rule 72 (type -> UNSIGNED_TYPE .)
    ASSIGN          reduce using rule 72 (type -> UNSIGNED_TYPE .)
    END             reduce using rule 72 (type -> UNSIGNED_TYPE .)


state 20

    (73) type -> SIGNED_TYPE .
    COMMA           reduce using rule 73 (type -> SIGNED_TYPE .)
    RPAREN          reduce using rule 73 (type -> SIGNED_TYPE .)
    LBRACE          reduce using rule 73 (type -> SIGNED_TYPE .)
    ASSIGN          reduce using rule 73 (type -> SIGNED_TYPE .)
    END             reduce using rule 73 (type -> SIGNED_TYPE .)


state 21

    (4) function -> ID LPAREN formal_params RPAREN COLON . type scope
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 25

state 22

    (6) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 26


state 23

    (7) formal_params -> ID COLON type multi_formal_params .
    RPAREN          reduce using rule 7 (formal_params -> ID COLON type multi_formal_params .)


state 24

    (9) multi_formal_params -> COMMA . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (10) multi_formal_params -> COMMA . ID COLON type multi_formal_params
    ID              shift and go to state 27


state 25

    (4) function -> ID LPAREN formal_params RPAREN COLON type . scope
    (16) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 29

    scope                          shift and go to state 28

state 26

    (6) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type multi_formal_params
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 30

state 27

    (9) multi_formal_params -> COMMA ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (10) multi_formal_params -> COMMA ID . COLON type multi_formal_params
    LSBRACKET       shift and go to state 31
    COLON           shift and go to state 32


state 28

    (4) function -> ID LPAREN formal_params RPAREN COLON type scope .
    ID              reduce using rule 4 (function -> ID LPAREN formal_params RPAREN COLON type scope .)
    $end            reduce using rule 4 (function -> ID LPAREN formal_params RPAREN COLON type scope .)


state 29

    (16) scope -> LBRACE . new_scope statements pop_scope RBRACE
    (17) new_scope -> .
    END             reduce using rule 17 (new_scope -> .)
    IF              reduce using rule 17 (new_scope -> .)
    FOR             reduce using rule 17 (new_scope -> .)
    WHILE           reduce using rule 17 (new_scope -> .)
    LBRACE          reduce using rule 17 (new_scope -> .)
    ID              reduce using rule 17 (new_scope -> .)
    DECLARE         reduce using rule 17 (new_scope -> .)
    LPAREN          reduce using rule 17 (new_scope -> .)
    STRING_VALUE    reduce using rule 17 (new_scope -> .)
    CHAR_VALUE      reduce using rule 17 (new_scope -> .)
    BOOL_VALUE      reduce using rule 17 (new_scope -> .)
    FLOAT_VALUE     reduce using rule 17 (new_scope -> .)
    INTEGRAL_VALUE  reduce using rule 17 (new_scope -> .)
    RBRACE          reduce using rule 17 (new_scope -> .)

    new_scope                      shift and go to state 33

state 30

    (6) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . multi_formal_params
    (8) multi_formal_params -> .
    (9) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (10) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 8 (multi_formal_params -> .)
    COMMA           shift and go to state 24

    multi_formal_params            shift and go to state 34

state 31

    (9) multi_formal_params -> COMMA ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    INTEGRAL_VALUE  shift and go to state 35


state 32

    (10) multi_formal_params -> COMMA ID COLON . type multi_formal_params
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 36

state 33

    (16) scope -> LBRACE new_scope . statements pop_scope RBRACE
    (19) statements -> .
    (20) statements -> . statement statements
    (21) statement -> . END
    (22) statement -> . if_statement
    (23) statement -> . for_statement
    (24) statement -> . while_statement
    (25) statement -> . scope
    (26) statement -> . array_assignment END
    (27) statement -> . scalar_assignment END
    (28) statement -> . array_declaration_init END
    (29) statement -> . scalar_declaration_init END
    (30) statement -> . array_declaration END
    (31) statement -> . scalar_declaration END
    (32) statement -> . expression END
    (41) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (39) for_statement -> . FOR LPAREN for_component END expression END for_component RPAREN scope
    (40) while_statement -> . WHILE LPAREN expression RPAREN scope
    (16) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (50) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (49) scalar_assignment -> . ID ASSIGN expression
    (48) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (46) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (45) scalar_declaration -> . DECLARE ID COLON type
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 19 (statements -> .)
    END             shift and go to state 39
    IF              shift and go to state 51
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    LBRACE          shift and go to state 29
    ID              shift and go to state 55
    DECLARE         shift and go to state 57
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    statements                     shift and go to state 37
    statement                      shift and go to state 38
    if_statement                   shift and go to state 40
    for_statement                  shift and go to state 41
    while_statement                shift and go to state 42
    scope                          shift and go to state 43
    array_assignment               shift and go to state 44
    scalar_assignment              shift and go to state 45
    array_declaration_init         shift and go to state 46
    scalar_declaration_init        shift and go to state 47
    array_declaration              shift and go to state 48
    scalar_declaration             shift and go to state 49
    expression                     shift and go to state 50
    arithmetic_layer               shift and go to state 56
    comparison_layer               shift and go to state 59
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 34

    (6) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 6 (formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .)


state 35

    (9) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 68


state 36

    (10) multi_formal_params -> COMMA ID COLON type . multi_formal_params
    (8) multi_formal_params -> .
    (9) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (10) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 8 (multi_formal_params -> .)
    COMMA           shift and go to state 24

    multi_formal_params            shift and go to state 69

state 37

    (16) scope -> LBRACE new_scope statements . pop_scope RBRACE
    (18) pop_scope -> .
    RBRACE          reduce using rule 18 (pop_scope -> .)

    pop_scope                      shift and go to state 70

state 38

    (20) statements -> statement . statements
    (19) statements -> .
    (20) statements -> . statement statements
    (21) statement -> . END
    (22) statement -> . if_statement
    (23) statement -> . for_statement
    (24) statement -> . while_statement
    (25) statement -> . scope
    (26) statement -> . array_assignment END
    (27) statement -> . scalar_assignment END
    (28) statement -> . array_declaration_init END
    (29) statement -> . scalar_declaration_init END
    (30) statement -> . array_declaration END
    (31) statement -> . scalar_declaration END
    (32) statement -> . expression END
    (41) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (39) for_statement -> . FOR LPAREN for_component END expression END for_component RPAREN scope
    (40) while_statement -> . WHILE LPAREN expression RPAREN scope
    (16) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (50) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (49) scalar_assignment -> . ID ASSIGN expression
    (48) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (46) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (45) scalar_declaration -> . DECLARE ID COLON type
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 19 (statements -> .)
    END             shift and go to state 39
    IF              shift and go to state 51
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    LBRACE          shift and go to state 29
    ID              shift and go to state 55
    DECLARE         shift and go to state 57
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    statement                      shift and go to state 38
    statements                     shift and go to state 71
    if_statement                   shift and go to state 40
    for_statement                  shift and go to state 41
    while_statement                shift and go to state 42
    scope                          shift and go to state 43
    array_assignment               shift and go to state 44
    scalar_assignment              shift and go to state 45
    array_declaration_init         shift and go to state 46
    scalar_declaration_init        shift and go to state 47
    array_declaration              shift and go to state 48
    scalar_declaration             shift and go to state 49
    expression                     shift and go to state 50
    arithmetic_layer               shift and go to state 56
    comparison_layer               shift and go to state 59
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 39

    (21) statement -> END .
    END             reduce using rule 21 (statement -> END .)
    IF              reduce using rule 21 (statement -> END .)
    FOR             reduce using rule 21 (statement -> END .)
    WHILE           reduce using rule 21 (statement -> END .)
    LBRACE          reduce using rule 21 (statement -> END .)
    ID              reduce using rule 21 (statement -> END .)
    DECLARE         reduce using rule 21 (statement -> END .)
    LPAREN          reduce using rule 21 (statement -> END .)
    STRING_VALUE    reduce using rule 21 (statement -> END .)
    CHAR_VALUE      reduce using rule 21 (statement -> END .)
    BOOL_VALUE      reduce using rule 21 (statement -> END .)
    FLOAT_VALUE     reduce using rule 21 (statement -> END .)
    INTEGRAL_VALUE  reduce using rule 21 (statement -> END .)
    RBRACE          reduce using rule 21 (statement -> END .)


state 40

    (22) statement -> if_statement .
    END             reduce using rule 22 (statement -> if_statement .)
    IF              reduce using rule 22 (statement -> if_statement .)
    FOR             reduce using rule 22 (statement -> if_statement .)
    WHILE           reduce using rule 22 (statement -> if_statement .)
    LBRACE          reduce using rule 22 (statement -> if_statement .)
    ID              reduce using rule 22 (statement -> if_statement .)
    DECLARE         reduce using rule 22 (statement -> if_statement .)
    LPAREN          reduce using rule 22 (statement -> if_statement .)
    STRING_VALUE    reduce using rule 22 (statement -> if_statement .)
    CHAR_VALUE      reduce using rule 22 (statement -> if_statement .)
    BOOL_VALUE      reduce using rule 22 (statement -> if_statement .)
    FLOAT_VALUE     reduce using rule 22 (statement -> if_statement .)
    INTEGRAL_VALUE  reduce using rule 22 (statement -> if_statement .)
    RBRACE          reduce using rule 22 (statement -> if_statement .)


state 41

    (23) statement -> for_statement .
    END             reduce using rule 23 (statement -> for_statement .)
    IF              reduce using rule 23 (statement -> for_statement .)
    FOR             reduce using rule 23 (statement -> for_statement .)
    WHILE           reduce using rule 23 (statement -> for_statement .)
    LBRACE          reduce using rule 23 (statement -> for_statement .)
    ID              reduce using rule 23 (statement -> for_statement .)
    DECLARE         reduce using rule 23 (statement -> for_statement .)
    LPAREN          reduce using rule 23 (statement -> for_statement .)
    STRING_VALUE    reduce using rule 23 (statement -> for_statement .)
    CHAR_VALUE      reduce using rule 23 (statement -> for_statement .)
    BOOL_VALUE      reduce using rule 23 (statement -> for_statement .)
    FLOAT_VALUE     reduce using rule 23 (statement -> for_statement .)
    INTEGRAL_VALUE  reduce using rule 23 (statement -> for_statement .)
    RBRACE          reduce using rule 23 (statement -> for_statement .)


state 42

    (24) statement -> while_statement .
    END             reduce using rule 24 (statement -> while_statement .)
    IF              reduce using rule 24 (statement -> while_statement .)
    FOR             reduce using rule 24 (statement -> while_statement .)
    WHILE           reduce using rule 24 (statement -> while_statement .)
    LBRACE          reduce using rule 24 (statement -> while_statement .)
    ID              reduce using rule 24 (statement -> while_statement .)
    DECLARE         reduce using rule 24 (statement -> while_statement .)
    LPAREN          reduce using rule 24 (statement -> while_statement .)
    STRING_VALUE    reduce using rule 24 (statement -> while_statement .)
    CHAR_VALUE      reduce using rule 24 (statement -> while_statement .)
    BOOL_VALUE      reduce using rule 24 (statement -> while_statement .)
    FLOAT_VALUE     reduce using rule 24 (statement -> while_statement .)
    INTEGRAL_VALUE  reduce using rule 24 (statement -> while_statement .)
    RBRACE          reduce using rule 24 (statement -> while_statement .)


state 43

    (25) statement -> scope .
    END             reduce using rule 25 (statement -> scope .)
    IF              reduce using rule 25 (statement -> scope .)
    FOR             reduce using rule 25 (statement -> scope .)
    WHILE           reduce using rule 25 (statement -> scope .)
    LBRACE          reduce using rule 25 (statement -> scope .)
    ID              reduce using rule 25 (statement -> scope .)
    DECLARE         reduce using rule 25 (statement -> scope .)
    LPAREN          reduce using rule 25 (statement -> scope .)
    STRING_VALUE    reduce using rule 25 (statement -> scope .)
    CHAR_VALUE      reduce using rule 25 (statement -> scope .)
    BOOL_VALUE      reduce using rule 25 (statement -> scope .)
    FLOAT_VALUE     reduce using rule 25 (statement -> scope .)
    INTEGRAL_VALUE  reduce using rule 25 (statement -> scope .)
    RBRACE          reduce using rule 25 (statement -> scope .)


state 44

    (26) statement -> array_assignment . END
    END             shift and go to state 72


state 45

    (27) statement -> scalar_assignment . END
    END             shift and go to state 73


state 46

    (28) statement -> array_declaration_init . END
    END             shift and go to state 74


state 47

    (29) statement -> scalar_declaration_init . END
    END             shift and go to state 75


state 48

    (30) statement -> array_declaration . END
    END             shift and go to state 76


state 49

    (31) statement -> scalar_declaration . END
    END             shift and go to state 77


state 50

    (32) statement -> expression . END
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    END             shift and go to state 78
    OR              shift and go to state 79
    AND             shift and go to state 80


state 51

    (41) if_statement -> IF . LPAREN expression RPAREN scope else_statement
    LPAREN          shift and go to state 81


state 52

    (65) factor -> LPAREN . expression RPAREN
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 82
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 53

    (39) for_statement -> FOR . LPAREN for_component END expression END for_component RPAREN scope
    LPAREN          shift and go to state 84


state 54

    (40) while_statement -> WHILE . LPAREN expression RPAREN scope
    LPAREN          shift and go to state 85


state 55

    (50) array_assignment -> ID . LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (49) scalar_assignment -> ID . ASSIGN expression
    (62) factor -> ID .
    (63) factor -> ID . LSBRACKET arithmetic_layer RSBRACKET
    (11) function_call -> ID . LPAREN actual_params RPAREN
    LSBRACKET       shift and go to state 86
    ASSIGN          shift and go to state 87
    DIVISION        reduce using rule 62 (factor -> ID .)
    MULTIPLICATION  reduce using rule 62 (factor -> ID .)
    MINUS           reduce using rule 62 (factor -> ID .)
    PLUS            reduce using rule 62 (factor -> ID .)
    COMPARATOR      reduce using rule 62 (factor -> ID .)
    END             reduce using rule 62 (factor -> ID .)
    OR              reduce using rule 62 (factor -> ID .)
    AND             reduce using rule 62 (factor -> ID .)
    RPAREN          reduce using rule 62 (factor -> ID .)
    LPAREN          shift and go to state 88


state 56

    (54) comparison_layer -> arithmetic_layer .
    (57) arithmetic_layer -> arithmetic_layer . MINUS term
    (58) arithmetic_layer -> arithmetic_layer . PLUS term
    COMPARATOR      reduce using rule 54 (comparison_layer -> arithmetic_layer .)
    END             reduce using rule 54 (comparison_layer -> arithmetic_layer .)
    OR              reduce using rule 54 (comparison_layer -> arithmetic_layer .)
    AND             reduce using rule 54 (comparison_layer -> arithmetic_layer .)
    RPAREN          reduce using rule 54 (comparison_layer -> arithmetic_layer .)
    COMMA           reduce using rule 54 (comparison_layer -> arithmetic_layer .)
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90


state 57

    (48) array_declaration_init -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> DECLARE . ID COLON type ASSIGN expression
    (46) array_declaration -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (45) scalar_declaration -> DECLARE . ID COLON type
    ID              shift and go to state 91


state 58

    (78) value -> INTEGRAL_VALUE .
    DIVISION        reduce using rule 78 (value -> INTEGRAL_VALUE .)
    MULTIPLICATION  reduce using rule 78 (value -> INTEGRAL_VALUE .)
    MINUS           reduce using rule 78 (value -> INTEGRAL_VALUE .)
    PLUS            reduce using rule 78 (value -> INTEGRAL_VALUE .)
    COMPARATOR      reduce using rule 78 (value -> INTEGRAL_VALUE .)
    END             reduce using rule 78 (value -> INTEGRAL_VALUE .)
    OR              reduce using rule 78 (value -> INTEGRAL_VALUE .)
    AND             reduce using rule 78 (value -> INTEGRAL_VALUE .)
    RPAREN          reduce using rule 78 (value -> INTEGRAL_VALUE .)
    COMMA           reduce using rule 78 (value -> INTEGRAL_VALUE .)
    RSBRACKET       reduce using rule 78 (value -> INTEGRAL_VALUE .)


state 59

    (51) expression -> comparison_layer .
    (55) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 51 (expression -> comparison_layer .)
    OR              reduce using rule 51 (expression -> comparison_layer .)
    AND             reduce using rule 51 (expression -> comparison_layer .)
    RPAREN          reduce using rule 51 (expression -> comparison_layer .)
    COMMA           reduce using rule 51 (expression -> comparison_layer .)
    COMPARATOR      shift and go to state 92


state 60

    (56) arithmetic_layer -> term .
    (60) term -> term . DIVISION factor
    (61) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 56 (arithmetic_layer -> term .)
    PLUS            reduce using rule 56 (arithmetic_layer -> term .)
    COMPARATOR      reduce using rule 56 (arithmetic_layer -> term .)
    END             reduce using rule 56 (arithmetic_layer -> term .)
    OR              reduce using rule 56 (arithmetic_layer -> term .)
    AND             reduce using rule 56 (arithmetic_layer -> term .)
    RPAREN          reduce using rule 56 (arithmetic_layer -> term .)
    COMMA           reduce using rule 56 (arithmetic_layer -> term .)
    RSBRACKET       reduce using rule 56 (arithmetic_layer -> term .)
    DIVISION        shift and go to state 93
    MULTIPLICATION  shift and go to state 94


state 61

    (59) term -> factor .
    DIVISION        reduce using rule 59 (term -> factor .)
    MULTIPLICATION  reduce using rule 59 (term -> factor .)
    MINUS           reduce using rule 59 (term -> factor .)
    PLUS            reduce using rule 59 (term -> factor .)
    COMPARATOR      reduce using rule 59 (term -> factor .)
    END             reduce using rule 59 (term -> factor .)
    OR              reduce using rule 59 (term -> factor .)
    AND             reduce using rule 59 (term -> factor .)
    RPAREN          reduce using rule 59 (term -> factor .)
    COMMA           reduce using rule 59 (term -> factor .)
    RSBRACKET       reduce using rule 59 (term -> factor .)


state 62

    (64) factor -> value .
    DIVISION        reduce using rule 64 (factor -> value .)
    MULTIPLICATION  reduce using rule 64 (factor -> value .)
    MINUS           reduce using rule 64 (factor -> value .)
    PLUS            reduce using rule 64 (factor -> value .)
    COMPARATOR      reduce using rule 64 (factor -> value .)
    END             reduce using rule 64 (factor -> value .)
    OR              reduce using rule 64 (factor -> value .)
    AND             reduce using rule 64 (factor -> value .)
    RPAREN          reduce using rule 64 (factor -> value .)
    COMMA           reduce using rule 64 (factor -> value .)
    RSBRACKET       reduce using rule 64 (factor -> value .)


state 63

    (66) factor -> function_call .
    DIVISION        reduce using rule 66 (factor -> function_call .)
    MULTIPLICATION  reduce using rule 66 (factor -> function_call .)
    MINUS           reduce using rule 66 (factor -> function_call .)
    PLUS            reduce using rule 66 (factor -> function_call .)
    COMPARATOR      reduce using rule 66 (factor -> function_call .)
    END             reduce using rule 66 (factor -> function_call .)
    OR              reduce using rule 66 (factor -> function_call .)
    AND             reduce using rule 66 (factor -> function_call .)
    RPAREN          reduce using rule 66 (factor -> function_call .)
    COMMA           reduce using rule 66 (factor -> function_call .)
    RSBRACKET       reduce using rule 66 (factor -> function_call .)


state 64

    (74) value -> STRING_VALUE .
    DIVISION        reduce using rule 74 (value -> STRING_VALUE .)
    MULTIPLICATION  reduce using rule 74 (value -> STRING_VALUE .)
    MINUS           reduce using rule 74 (value -> STRING_VALUE .)
    PLUS            reduce using rule 74 (value -> STRING_VALUE .)
    COMPARATOR      reduce using rule 74 (value -> STRING_VALUE .)
    END             reduce using rule 74 (value -> STRING_VALUE .)
    OR              reduce using rule 74 (value -> STRING_VALUE .)
    AND             reduce using rule 74 (value -> STRING_VALUE .)
    RPAREN          reduce using rule 74 (value -> STRING_VALUE .)
    COMMA           reduce using rule 74 (value -> STRING_VALUE .)
    RSBRACKET       reduce using rule 74 (value -> STRING_VALUE .)


state 65

    (75) value -> CHAR_VALUE .
    DIVISION        reduce using rule 75 (value -> CHAR_VALUE .)
    MULTIPLICATION  reduce using rule 75 (value -> CHAR_VALUE .)
    MINUS           reduce using rule 75 (value -> CHAR_VALUE .)
    PLUS            reduce using rule 75 (value -> CHAR_VALUE .)
    COMPARATOR      reduce using rule 75 (value -> CHAR_VALUE .)
    END             reduce using rule 75 (value -> CHAR_VALUE .)
    OR              reduce using rule 75 (value -> CHAR_VALUE .)
    AND             reduce using rule 75 (value -> CHAR_VALUE .)
    RPAREN          reduce using rule 75 (value -> CHAR_VALUE .)
    COMMA           reduce using rule 75 (value -> CHAR_VALUE .)
    RSBRACKET       reduce using rule 75 (value -> CHAR_VALUE .)


state 66

    (76) value -> BOOL_VALUE .
    DIVISION        reduce using rule 76 (value -> BOOL_VALUE .)
    MULTIPLICATION  reduce using rule 76 (value -> BOOL_VALUE .)
    MINUS           reduce using rule 76 (value -> BOOL_VALUE .)
    PLUS            reduce using rule 76 (value -> BOOL_VALUE .)
    COMPARATOR      reduce using rule 76 (value -> BOOL_VALUE .)
    END             reduce using rule 76 (value -> BOOL_VALUE .)
    OR              reduce using rule 76 (value -> BOOL_VALUE .)
    AND             reduce using rule 76 (value -> BOOL_VALUE .)
    RPAREN          reduce using rule 76 (value -> BOOL_VALUE .)
    COMMA           reduce using rule 76 (value -> BOOL_VALUE .)
    RSBRACKET       reduce using rule 76 (value -> BOOL_VALUE .)


state 67

    (77) value -> FLOAT_VALUE .
    DIVISION        reduce using rule 77 (value -> FLOAT_VALUE .)
    MULTIPLICATION  reduce using rule 77 (value -> FLOAT_VALUE .)
    MINUS           reduce using rule 77 (value -> FLOAT_VALUE .)
    PLUS            reduce using rule 77 (value -> FLOAT_VALUE .)
    COMPARATOR      reduce using rule 77 (value -> FLOAT_VALUE .)
    END             reduce using rule 77 (value -> FLOAT_VALUE .)
    OR              reduce using rule 77 (value -> FLOAT_VALUE .)
    AND             reduce using rule 77 (value -> FLOAT_VALUE .)
    RPAREN          reduce using rule 77 (value -> FLOAT_VALUE .)
    COMMA           reduce using rule 77 (value -> FLOAT_VALUE .)
    RSBRACKET       reduce using rule 77 (value -> FLOAT_VALUE .)


state 68

    (9) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 95


state 69

    (10) multi_formal_params -> COMMA ID COLON type multi_formal_params .
    RPAREN          reduce using rule 10 (multi_formal_params -> COMMA ID COLON type multi_formal_params .)


state 70

    (16) scope -> LBRACE new_scope statements pop_scope . RBRACE
    RBRACE          shift and go to state 96


state 71

    (20) statements -> statement statements .
    RBRACE          reduce using rule 20 (statements -> statement statements .)


state 72

    (26) statement -> array_assignment END .
    END             reduce using rule 26 (statement -> array_assignment END .)
    IF              reduce using rule 26 (statement -> array_assignment END .)
    FOR             reduce using rule 26 (statement -> array_assignment END .)
    WHILE           reduce using rule 26 (statement -> array_assignment END .)
    LBRACE          reduce using rule 26 (statement -> array_assignment END .)
    ID              reduce using rule 26 (statement -> array_assignment END .)
    DECLARE         reduce using rule 26 (statement -> array_assignment END .)
    LPAREN          reduce using rule 26 (statement -> array_assignment END .)
    STRING_VALUE    reduce using rule 26 (statement -> array_assignment END .)
    CHAR_VALUE      reduce using rule 26 (statement -> array_assignment END .)
    BOOL_VALUE      reduce using rule 26 (statement -> array_assignment END .)
    FLOAT_VALUE     reduce using rule 26 (statement -> array_assignment END .)
    INTEGRAL_VALUE  reduce using rule 26 (statement -> array_assignment END .)
    RBRACE          reduce using rule 26 (statement -> array_assignment END .)


state 73

    (27) statement -> scalar_assignment END .
    END             reduce using rule 27 (statement -> scalar_assignment END .)
    IF              reduce using rule 27 (statement -> scalar_assignment END .)
    FOR             reduce using rule 27 (statement -> scalar_assignment END .)
    WHILE           reduce using rule 27 (statement -> scalar_assignment END .)
    LBRACE          reduce using rule 27 (statement -> scalar_assignment END .)
    ID              reduce using rule 27 (statement -> scalar_assignment END .)
    DECLARE         reduce using rule 27 (statement -> scalar_assignment END .)
    LPAREN          reduce using rule 27 (statement -> scalar_assignment END .)
    STRING_VALUE    reduce using rule 27 (statement -> scalar_assignment END .)
    CHAR_VALUE      reduce using rule 27 (statement -> scalar_assignment END .)
    BOOL_VALUE      reduce using rule 27 (statement -> scalar_assignment END .)
    FLOAT_VALUE     reduce using rule 27 (statement -> scalar_assignment END .)
    INTEGRAL_VALUE  reduce using rule 27 (statement -> scalar_assignment END .)
    RBRACE          reduce using rule 27 (statement -> scalar_assignment END .)


state 74

    (28) statement -> array_declaration_init END .
    END             reduce using rule 28 (statement -> array_declaration_init END .)
    IF              reduce using rule 28 (statement -> array_declaration_init END .)
    FOR             reduce using rule 28 (statement -> array_declaration_init END .)
    WHILE           reduce using rule 28 (statement -> array_declaration_init END .)
    LBRACE          reduce using rule 28 (statement -> array_declaration_init END .)
    ID              reduce using rule 28 (statement -> array_declaration_init END .)
    DECLARE         reduce using rule 28 (statement -> array_declaration_init END .)
    LPAREN          reduce using rule 28 (statement -> array_declaration_init END .)
    STRING_VALUE    reduce using rule 28 (statement -> array_declaration_init END .)
    CHAR_VALUE      reduce using rule 28 (statement -> array_declaration_init END .)
    BOOL_VALUE      reduce using rule 28 (statement -> array_declaration_init END .)
    FLOAT_VALUE     reduce using rule 28 (statement -> array_declaration_init END .)
    INTEGRAL_VALUE  reduce using rule 28 (statement -> array_declaration_init END .)
    RBRACE          reduce using rule 28 (statement -> array_declaration_init END .)


state 75

    (29) statement -> scalar_declaration_init END .
    END             reduce using rule 29 (statement -> scalar_declaration_init END .)
    IF              reduce using rule 29 (statement -> scalar_declaration_init END .)
    FOR             reduce using rule 29 (statement -> scalar_declaration_init END .)
    WHILE           reduce using rule 29 (statement -> scalar_declaration_init END .)
    LBRACE          reduce using rule 29 (statement -> scalar_declaration_init END .)
    ID              reduce using rule 29 (statement -> scalar_declaration_init END .)
    DECLARE         reduce using rule 29 (statement -> scalar_declaration_init END .)
    LPAREN          reduce using rule 29 (statement -> scalar_declaration_init END .)
    STRING_VALUE    reduce using rule 29 (statement -> scalar_declaration_init END .)
    CHAR_VALUE      reduce using rule 29 (statement -> scalar_declaration_init END .)
    BOOL_VALUE      reduce using rule 29 (statement -> scalar_declaration_init END .)
    FLOAT_VALUE     reduce using rule 29 (statement -> scalar_declaration_init END .)
    INTEGRAL_VALUE  reduce using rule 29 (statement -> scalar_declaration_init END .)
    RBRACE          reduce using rule 29 (statement -> scalar_declaration_init END .)


state 76

    (30) statement -> array_declaration END .
    END             reduce using rule 30 (statement -> array_declaration END .)
    IF              reduce using rule 30 (statement -> array_declaration END .)
    FOR             reduce using rule 30 (statement -> array_declaration END .)
    WHILE           reduce using rule 30 (statement -> array_declaration END .)
    LBRACE          reduce using rule 30 (statement -> array_declaration END .)
    ID              reduce using rule 30 (statement -> array_declaration END .)
    DECLARE         reduce using rule 30 (statement -> array_declaration END .)
    LPAREN          reduce using rule 30 (statement -> array_declaration END .)
    STRING_VALUE    reduce using rule 30 (statement -> array_declaration END .)
    CHAR_VALUE      reduce using rule 30 (statement -> array_declaration END .)
    BOOL_VALUE      reduce using rule 30 (statement -> array_declaration END .)
    FLOAT_VALUE     reduce using rule 30 (statement -> array_declaration END .)
    INTEGRAL_VALUE  reduce using rule 30 (statement -> array_declaration END .)
    RBRACE          reduce using rule 30 (statement -> array_declaration END .)


state 77

    (31) statement -> scalar_declaration END .
    END             reduce using rule 31 (statement -> scalar_declaration END .)
    IF              reduce using rule 31 (statement -> scalar_declaration END .)
    FOR             reduce using rule 31 (statement -> scalar_declaration END .)
    WHILE           reduce using rule 31 (statement -> scalar_declaration END .)
    LBRACE          reduce using rule 31 (statement -> scalar_declaration END .)
    ID              reduce using rule 31 (statement -> scalar_declaration END .)
    DECLARE         reduce using rule 31 (statement -> scalar_declaration END .)
    LPAREN          reduce using rule 31 (statement -> scalar_declaration END .)
    STRING_VALUE    reduce using rule 31 (statement -> scalar_declaration END .)
    CHAR_VALUE      reduce using rule 31 (statement -> scalar_declaration END .)
    BOOL_VALUE      reduce using rule 31 (statement -> scalar_declaration END .)
    FLOAT_VALUE     reduce using rule 31 (statement -> scalar_declaration END .)
    INTEGRAL_VALUE  reduce using rule 31 (statement -> scalar_declaration END .)
    RBRACE          reduce using rule 31 (statement -> scalar_declaration END .)


state 78

    (32) statement -> expression END .
    END             reduce using rule 32 (statement -> expression END .)
    IF              reduce using rule 32 (statement -> expression END .)
    FOR             reduce using rule 32 (statement -> expression END .)
    WHILE           reduce using rule 32 (statement -> expression END .)
    LBRACE          reduce using rule 32 (statement -> expression END .)
    ID              reduce using rule 32 (statement -> expression END .)
    DECLARE         reduce using rule 32 (statement -> expression END .)
    LPAREN          reduce using rule 32 (statement -> expression END .)
    STRING_VALUE    reduce using rule 32 (statement -> expression END .)
    CHAR_VALUE      reduce using rule 32 (statement -> expression END .)
    BOOL_VALUE      reduce using rule 32 (statement -> expression END .)
    FLOAT_VALUE     reduce using rule 32 (statement -> expression END .)
    INTEGRAL_VALUE  reduce using rule 32 (statement -> expression END .)
    RBRACE          reduce using rule 32 (statement -> expression END .)


state 79

    (52) expression -> expression OR . comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    comparison_layer               shift and go to state 97
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 80

    (53) expression -> expression AND . comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    comparison_layer               shift and go to state 98
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 81

    (41) if_statement -> IF LPAREN . expression RPAREN scope else_statement
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 99
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 82

    (65) factor -> LPAREN expression . RPAREN
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 100
    OR              shift and go to state 79
    AND             shift and go to state 80


state 83

    (62) factor -> ID .
    (63) factor -> ID . LSBRACKET arithmetic_layer RSBRACKET
    (11) function_call -> ID . LPAREN actual_params RPAREN
    DIVISION        reduce using rule 62 (factor -> ID .)
    MULTIPLICATION  reduce using rule 62 (factor -> ID .)
    MINUS           reduce using rule 62 (factor -> ID .)
    PLUS            reduce using rule 62 (factor -> ID .)
    COMPARATOR      reduce using rule 62 (factor -> ID .)
    RPAREN          reduce using rule 62 (factor -> ID .)
    OR              reduce using rule 62 (factor -> ID .)
    AND             reduce using rule 62 (factor -> ID .)
    END             reduce using rule 62 (factor -> ID .)
    COMMA           reduce using rule 62 (factor -> ID .)
    RSBRACKET       reduce using rule 62 (factor -> ID .)
    LSBRACKET       shift and go to state 101
    LPAREN          shift and go to state 88


state 84

    (39) for_statement -> FOR LPAREN . for_component END expression END for_component RPAREN scope
    (33) for_component -> .
    (34) for_component -> . expression
    (35) for_component -> . array_declaration_init
    (36) for_component -> . scalar_declaration_init
    (37) for_component -> . array_assignment
    (38) for_component -> . scalar_assignment
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (48) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (50) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (49) scalar_assignment -> . ID ASSIGN expression
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    END             reduce using rule 33 (for_component -> .)
    DECLARE         shift and go to state 108
    ID              shift and go to state 55
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    for_component                  shift and go to state 102
    expression                     shift and go to state 103
    array_declaration_init         shift and go to state 104
    scalar_declaration_init        shift and go to state 105
    array_assignment               shift and go to state 106
    scalar_assignment              shift and go to state 107
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 85

    (40) while_statement -> WHILE LPAREN . expression RPAREN scope
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 109
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 86

    (50) array_assignment -> ID LSBRACKET . arithmetic_layer RSBRACKET ASSIGN expression
    (63) factor -> ID LSBRACKET . arithmetic_layer RSBRACKET
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    arithmetic_layer               shift and go to state 110
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 87

    (49) scalar_assignment -> ID ASSIGN . expression
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 111
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 88

    (11) function_call -> ID LPAREN . actual_params RPAREN
    (12) actual_params -> .
    (13) actual_params -> . expression multi_actual_params
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    RPAREN          reduce using rule 12 (actual_params -> .)
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    actual_params                  shift and go to state 112
    expression                     shift and go to state 113
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 89

    (57) arithmetic_layer -> arithmetic_layer MINUS . term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    term                           shift and go to state 114
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 90

    (58) arithmetic_layer -> arithmetic_layer PLUS . term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    term                           shift and go to state 115
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 91

    (48) array_declaration_init -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> DECLARE ID . COLON type ASSIGN expression
    (46) array_declaration -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (45) scalar_declaration -> DECLARE ID . COLON type
    LSBRACKET       shift and go to state 116
    COLON           shift and go to state 117


state 92

    (55) comparison_layer -> comparison_layer COMPARATOR . arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    arithmetic_layer               shift and go to state 118
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 93

    (60) term -> term DIVISION . factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    factor                         shift and go to state 119
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 94

    (61) term -> term MULTIPLICATION . factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    factor                         shift and go to state 120
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 95

    (9) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type multi_formal_params
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 121

state 96

    (16) scope -> LBRACE new_scope statements pop_scope RBRACE .
    ID              reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    $end            reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    END             reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    IF              reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    FOR             reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    WHILE           reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    LBRACE          reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    DECLARE         reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    LPAREN          reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    STRING_VALUE    reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    CHAR_VALUE      reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    BOOL_VALUE      reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    FLOAT_VALUE     reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    INTEGRAL_VALUE  reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    RBRACE          reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    ELSE            reduce using rule 16 (scope -> LBRACE new_scope statements pop_scope RBRACE .)


state 97

    (52) expression -> expression OR comparison_layer .
    (55) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 52 (expression -> expression OR comparison_layer .)
    OR              reduce using rule 52 (expression -> expression OR comparison_layer .)
    AND             reduce using rule 52 (expression -> expression OR comparison_layer .)
    RPAREN          reduce using rule 52 (expression -> expression OR comparison_layer .)
    COMMA           reduce using rule 52 (expression -> expression OR comparison_layer .)
    COMPARATOR      shift and go to state 92


state 98

    (53) expression -> expression AND comparison_layer .
    (55) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 53 (expression -> expression AND comparison_layer .)
    OR              reduce using rule 53 (expression -> expression AND comparison_layer .)
    AND             reduce using rule 53 (expression -> expression AND comparison_layer .)
    RPAREN          reduce using rule 53 (expression -> expression AND comparison_layer .)
    COMMA           reduce using rule 53 (expression -> expression AND comparison_layer .)
    COMPARATOR      shift and go to state 92


state 99

    (41) if_statement -> IF LPAREN expression . RPAREN scope else_statement
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 122
    OR              shift and go to state 79
    AND             shift and go to state 80


state 100

    (65) factor -> LPAREN expression RPAREN .
    DIVISION        reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    MULTIPLICATION  reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    COMPARATOR      reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 65 (factor -> LPAREN expression RPAREN .)
    RSBRACKET       reduce using rule 65 (factor -> LPAREN expression RPAREN .)


state 101

    (63) factor -> ID LSBRACKET . arithmetic_layer RSBRACKET
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    arithmetic_layer               shift and go to state 123
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 102

    (39) for_statement -> FOR LPAREN for_component . END expression END for_component RPAREN scope
    END             shift and go to state 124


state 103

    (34) for_component -> expression .
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    END             reduce using rule 34 (for_component -> expression .)
    RPAREN          reduce using rule 34 (for_component -> expression .)
    OR              shift and go to state 79
    AND             shift and go to state 80


state 104

    (35) for_component -> array_declaration_init .
    END             reduce using rule 35 (for_component -> array_declaration_init .)
    RPAREN          reduce using rule 35 (for_component -> array_declaration_init .)


state 105

    (36) for_component -> scalar_declaration_init .
    END             reduce using rule 36 (for_component -> scalar_declaration_init .)
    RPAREN          reduce using rule 36 (for_component -> scalar_declaration_init .)


state 106

    (37) for_component -> array_assignment .
    END             reduce using rule 37 (for_component -> array_assignment .)
    RPAREN          reduce using rule 37 (for_component -> array_assignment .)


state 107

    (38) for_component -> scalar_assignment .
    END             reduce using rule 38 (for_component -> scalar_assignment .)
    RPAREN          reduce using rule 38 (for_component -> scalar_assignment .)


state 108

    (48) array_declaration_init -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> DECLARE . ID COLON type ASSIGN expression
    ID              shift and go to state 125


state 109

    (40) while_statement -> WHILE LPAREN expression . RPAREN scope
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 126
    OR              shift and go to state 79
    AND             shift and go to state 80


state 110

    (50) array_assignment -> ID LSBRACKET arithmetic_layer . RSBRACKET ASSIGN expression
    (63) factor -> ID LSBRACKET arithmetic_layer . RSBRACKET
    (57) arithmetic_layer -> arithmetic_layer . MINUS term
    (58) arithmetic_layer -> arithmetic_layer . PLUS term
    RSBRACKET       shift and go to state 127
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90


state 111

    (49) scalar_assignment -> ID ASSIGN expression .
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    END             reduce using rule 49 (scalar_assignment -> ID ASSIGN expression .)
    RPAREN          reduce using rule 49 (scalar_assignment -> ID ASSIGN expression .)
    OR              shift and go to state 79
    AND             shift and go to state 80


state 112

    (11) function_call -> ID LPAREN actual_params . RPAREN
    RPAREN          shift and go to state 128


state 113

    (13) actual_params -> expression . multi_actual_params
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    (14) multi_actual_params -> .
    (15) multi_actual_params -> . COMMA expression multi_actual_params
    OR              shift and go to state 79
    AND             shift and go to state 80
    RPAREN          reduce using rule 14 (multi_actual_params -> .)
    COMMA           shift and go to state 130

    multi_actual_params            shift and go to state 129

state 114

    (57) arithmetic_layer -> arithmetic_layer MINUS term .
    (60) term -> term . DIVISION factor
    (61) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    PLUS            reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    COMPARATOR      reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    END             reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    OR              reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    AND             reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    RPAREN          reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    COMMA           reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    RSBRACKET       reduce using rule 57 (arithmetic_layer -> arithmetic_layer MINUS term .)
    DIVISION        shift and go to state 93
    MULTIPLICATION  shift and go to state 94


state 115

    (58) arithmetic_layer -> arithmetic_layer PLUS term .
    (60) term -> term . DIVISION factor
    (61) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    PLUS            reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    COMPARATOR      reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    END             reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    OR              reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    AND             reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    RPAREN          reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    COMMA           reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    RSBRACKET       reduce using rule 58 (arithmetic_layer -> arithmetic_layer PLUS term .)
    DIVISION        shift and go to state 93
    MULTIPLICATION  shift and go to state 94


state 116

    (48) array_declaration_init -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (46) array_declaration -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type
    INTEGRAL_VALUE  shift and go to state 131


state 117

    (47) scalar_declaration_init -> DECLARE ID COLON . type ASSIGN expression
    (45) scalar_declaration -> DECLARE ID COLON . type
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 132

state 118

    (55) comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .
    (57) arithmetic_layer -> arithmetic_layer . MINUS term
    (58) arithmetic_layer -> arithmetic_layer . PLUS term
    COMPARATOR      reduce using rule 55 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    END             reduce using rule 55 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    OR              reduce using rule 55 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    AND             reduce using rule 55 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    RPAREN          reduce using rule 55 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    COMMA           reduce using rule 55 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90


state 119

    (60) term -> term DIVISION factor .
    DIVISION        reduce using rule 60 (term -> term DIVISION factor .)
    MULTIPLICATION  reduce using rule 60 (term -> term DIVISION factor .)
    MINUS           reduce using rule 60 (term -> term DIVISION factor .)
    PLUS            reduce using rule 60 (term -> term DIVISION factor .)
    COMPARATOR      reduce using rule 60 (term -> term DIVISION factor .)
    END             reduce using rule 60 (term -> term DIVISION factor .)
    OR              reduce using rule 60 (term -> term DIVISION factor .)
    AND             reduce using rule 60 (term -> term DIVISION factor .)
    RPAREN          reduce using rule 60 (term -> term DIVISION factor .)
    COMMA           reduce using rule 60 (term -> term DIVISION factor .)
    RSBRACKET       reduce using rule 60 (term -> term DIVISION factor .)


state 120

    (61) term -> term MULTIPLICATION factor .
    DIVISION        reduce using rule 61 (term -> term MULTIPLICATION factor .)
    MULTIPLICATION  reduce using rule 61 (term -> term MULTIPLICATION factor .)
    MINUS           reduce using rule 61 (term -> term MULTIPLICATION factor .)
    PLUS            reduce using rule 61 (term -> term MULTIPLICATION factor .)
    COMPARATOR      reduce using rule 61 (term -> term MULTIPLICATION factor .)
    END             reduce using rule 61 (term -> term MULTIPLICATION factor .)
    OR              reduce using rule 61 (term -> term MULTIPLICATION factor .)
    AND             reduce using rule 61 (term -> term MULTIPLICATION factor .)
    RPAREN          reduce using rule 61 (term -> term MULTIPLICATION factor .)
    COMMA           reduce using rule 61 (term -> term MULTIPLICATION factor .)
    RSBRACKET       reduce using rule 61 (term -> term MULTIPLICATION factor .)


state 121

    (9) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . multi_formal_params
    (8) multi_formal_params -> .
    (9) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (10) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 8 (multi_formal_params -> .)
    COMMA           shift and go to state 24

    multi_formal_params            shift and go to state 133

state 122

    (41) if_statement -> IF LPAREN expression RPAREN . scope else_statement
    (16) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 29

    scope                          shift and go to state 134

state 123

    (63) factor -> ID LSBRACKET arithmetic_layer . RSBRACKET
    (57) arithmetic_layer -> arithmetic_layer . MINUS term
    (58) arithmetic_layer -> arithmetic_layer . PLUS term
    RSBRACKET       shift and go to state 135
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90


state 124

    (39) for_statement -> FOR LPAREN for_component END . expression END for_component RPAREN scope
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 136
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 125

    (48) array_declaration_init -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> DECLARE ID . COLON type ASSIGN expression
    LSBRACKET       shift and go to state 137
    COLON           shift and go to state 138


state 126

    (40) while_statement -> WHILE LPAREN expression RPAREN . scope
    (16) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 29

    scope                          shift and go to state 139

state 127

    (50) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET . ASSIGN expression
    (63) factor -> ID LSBRACKET arithmetic_layer RSBRACKET .
    ASSIGN          shift and go to state 140
    DIVISION        reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MULTIPLICATION  reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MINUS           reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    PLUS            reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMPARATOR      reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    END             reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    OR              reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    AND             reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RPAREN          reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)


state 128

    (11) function_call -> ID LPAREN actual_params RPAREN .
    DIVISION        reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    MULTIPLICATION  reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    MINUS           reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    PLUS            reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    COMPARATOR      reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    END             reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    OR              reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    AND             reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    RPAREN          reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    COMMA           reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)
    RSBRACKET       reduce using rule 11 (function_call -> ID LPAREN actual_params RPAREN .)


state 129

    (13) actual_params -> expression multi_actual_params .
    RPAREN          reduce using rule 13 (actual_params -> expression multi_actual_params .)


state 130

    (15) multi_actual_params -> COMMA . expression multi_actual_params
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 141
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 131

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON ASSIGN expression
    (46) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type
    RSBRACKET       shift and go to state 142


state 132

    (47) scalar_declaration_init -> DECLARE ID COLON type . ASSIGN expression
    (45) scalar_declaration -> DECLARE ID COLON type .
    ASSIGN          shift and go to state 143
    END             reduce using rule 45 (scalar_declaration -> DECLARE ID COLON type .)


state 133

    (9) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 9 (multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .)


state 134

    (41) if_statement -> IF LPAREN expression RPAREN scope . else_statement
    (42) else_statement -> .
    (43) else_statement -> . ELSE if_statement
    (44) else_statement -> . ELSE scope
    END             reduce using rule 42 (else_statement -> .)
    IF              reduce using rule 42 (else_statement -> .)
    FOR             reduce using rule 42 (else_statement -> .)
    WHILE           reduce using rule 42 (else_statement -> .)
    LBRACE          reduce using rule 42 (else_statement -> .)
    ID              reduce using rule 42 (else_statement -> .)
    DECLARE         reduce using rule 42 (else_statement -> .)
    LPAREN          reduce using rule 42 (else_statement -> .)
    STRING_VALUE    reduce using rule 42 (else_statement -> .)
    CHAR_VALUE      reduce using rule 42 (else_statement -> .)
    BOOL_VALUE      reduce using rule 42 (else_statement -> .)
    FLOAT_VALUE     reduce using rule 42 (else_statement -> .)
    INTEGRAL_VALUE  reduce using rule 42 (else_statement -> .)
    RBRACE          reduce using rule 42 (else_statement -> .)
    ELSE            shift and go to state 145

    else_statement                 shift and go to state 144

state 135

    (63) factor -> ID LSBRACKET arithmetic_layer RSBRACKET .
    DIVISION        reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MULTIPLICATION  reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MINUS           reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    PLUS            reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMPARATOR      reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RPAREN          reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    OR              reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    AND             reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    END             reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMMA           reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RSBRACKET       reduce using rule 63 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)


state 136

    (39) for_statement -> FOR LPAREN for_component END expression . END for_component RPAREN scope
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    END             shift and go to state 146
    OR              shift and go to state 79
    AND             shift and go to state 80


state 137

    (48) array_declaration_init -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    INTEGRAL_VALUE  shift and go to state 147


state 138

    (47) scalar_declaration_init -> DECLARE ID COLON . type ASSIGN expression
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 148

state 139

    (40) while_statement -> WHILE LPAREN expression RPAREN scope .
    END             reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    IF              reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    FOR             reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    WHILE           reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    LBRACE          reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    ID              reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    DECLARE         reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    LPAREN          reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    STRING_VALUE    reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    CHAR_VALUE      reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    BOOL_VALUE      reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    FLOAT_VALUE     reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    INTEGRAL_VALUE  reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    RBRACE          reduce using rule 40 (while_statement -> WHILE LPAREN expression RPAREN scope .)


state 140

    (50) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN . expression
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    arithmetic_layer               shift and go to state 56
    expression                     shift and go to state 149
    comparison_layer               shift and go to state 59
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 141

    (15) multi_actual_params -> COMMA expression . multi_actual_params
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    (14) multi_actual_params -> .
    (15) multi_actual_params -> . COMMA expression multi_actual_params
    OR              shift and go to state 79
    AND             shift and go to state 80
    RPAREN          reduce using rule 14 (multi_actual_params -> .)
    COMMA           shift and go to state 130

    multi_actual_params            shift and go to state 150

state 142

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON ASSIGN expression
    (46) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type
    COLON           shift and go to state 151


state 143

    (47) scalar_declaration_init -> DECLARE ID COLON type ASSIGN . expression
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 152
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 144

    (41) if_statement -> IF LPAREN expression RPAREN scope else_statement .
    END             reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    IF              reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    FOR             reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    WHILE           reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    LBRACE          reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    ID              reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    DECLARE         reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    LPAREN          reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    STRING_VALUE    reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    CHAR_VALUE      reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    BOOL_VALUE      reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    FLOAT_VALUE     reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    INTEGRAL_VALUE  reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    RBRACE          reduce using rule 41 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)


state 145

    (43) else_statement -> ELSE . if_statement
    (44) else_statement -> ELSE . scope
    (41) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (16) scope -> . LBRACE new_scope statements pop_scope RBRACE
    IF              shift and go to state 51
    LBRACE          shift and go to state 29

    if_statement                   shift and go to state 153
    scope                          shift and go to state 154

state 146

    (39) for_statement -> FOR LPAREN for_component END expression END . for_component RPAREN scope
    (33) for_component -> .
    (34) for_component -> . expression
    (35) for_component -> . array_declaration_init
    (36) for_component -> . scalar_declaration_init
    (37) for_component -> . array_assignment
    (38) for_component -> . scalar_assignment
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (48) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression
    (47) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (50) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (49) scalar_assignment -> . ID ASSIGN expression
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    RPAREN          reduce using rule 33 (for_component -> .)
    DECLARE         shift and go to state 108
    ID              shift and go to state 55
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    for_component                  shift and go to state 155
    expression                     shift and go to state 103
    array_declaration_init         shift and go to state 104
    scalar_declaration_init        shift and go to state 105
    array_assignment               shift and go to state 106
    scalar_assignment              shift and go to state 107
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 147

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON ASSIGN expression
    RSBRACKET       shift and go to state 156


state 148

    (47) scalar_declaration_init -> DECLARE ID COLON type . ASSIGN expression
    ASSIGN          shift and go to state 143


state 149

    (50) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    END             reduce using rule 50 (array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .)
    RPAREN          reduce using rule 50 (array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .)
    OR              shift and go to state 79
    AND             shift and go to state 80


state 150

    (15) multi_actual_params -> COMMA expression multi_actual_params .
    RPAREN          reduce using rule 15 (multi_actual_params -> COMMA expression multi_actual_params .)


state 151

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . ASSIGN expression
    (46) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type
    (67) type -> . ABYSS_TYPE
    (68) type -> . BOOL_TYPE
    (69) type -> . STRING_TYPE
    (70) type -> . CHAR_TYPE
    (71) type -> . FLOAT_TYPE
    (72) type -> . UNSIGNED_TYPE
    (73) type -> . SIGNED_TYPE
    ASSIGN          shift and go to state 157
    ABYSS_TYPE      shift and go to state 14
    BOOL_TYPE       shift and go to state 15
    STRING_TYPE     shift and go to state 16
    CHAR_TYPE       shift and go to state 17
    FLOAT_TYPE      shift and go to state 18
    UNSIGNED_TYPE   shift and go to state 19
    SIGNED_TYPE     shift and go to state 20

    type                           shift and go to state 158

state 152

    (47) scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression .
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    END             reduce using rule 47 (scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression .)
    RPAREN          reduce using rule 47 (scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression .)
    OR              shift and go to state 79
    AND             shift and go to state 80


state 153

    (43) else_statement -> ELSE if_statement .
    END             reduce using rule 43 (else_statement -> ELSE if_statement .)
    IF              reduce using rule 43 (else_statement -> ELSE if_statement .)
    FOR             reduce using rule 43 (else_statement -> ELSE if_statement .)
    WHILE           reduce using rule 43 (else_statement -> ELSE if_statement .)
    LBRACE          reduce using rule 43 (else_statement -> ELSE if_statement .)
    ID              reduce using rule 43 (else_statement -> ELSE if_statement .)
    DECLARE         reduce using rule 43 (else_statement -> ELSE if_statement .)
    LPAREN          reduce using rule 43 (else_statement -> ELSE if_statement .)
    STRING_VALUE    reduce using rule 43 (else_statement -> ELSE if_statement .)
    CHAR_VALUE      reduce using rule 43 (else_statement -> ELSE if_statement .)
    BOOL_VALUE      reduce using rule 43 (else_statement -> ELSE if_statement .)
    FLOAT_VALUE     reduce using rule 43 (else_statement -> ELSE if_statement .)
    INTEGRAL_VALUE  reduce using rule 43 (else_statement -> ELSE if_statement .)
    RBRACE          reduce using rule 43 (else_statement -> ELSE if_statement .)


state 154

    (44) else_statement -> ELSE scope .
    END             reduce using rule 44 (else_statement -> ELSE scope .)
    IF              reduce using rule 44 (else_statement -> ELSE scope .)
    FOR             reduce using rule 44 (else_statement -> ELSE scope .)
    WHILE           reduce using rule 44 (else_statement -> ELSE scope .)
    LBRACE          reduce using rule 44 (else_statement -> ELSE scope .)
    ID              reduce using rule 44 (else_statement -> ELSE scope .)
    DECLARE         reduce using rule 44 (else_statement -> ELSE scope .)
    LPAREN          reduce using rule 44 (else_statement -> ELSE scope .)
    STRING_VALUE    reduce using rule 44 (else_statement -> ELSE scope .)
    CHAR_VALUE      reduce using rule 44 (else_statement -> ELSE scope .)
    BOOL_VALUE      reduce using rule 44 (else_statement -> ELSE scope .)
    FLOAT_VALUE     reduce using rule 44 (else_statement -> ELSE scope .)
    INTEGRAL_VALUE  reduce using rule 44 (else_statement -> ELSE scope .)
    RBRACE          reduce using rule 44 (else_statement -> ELSE scope .)


state 155

    (39) for_statement -> FOR LPAREN for_component END expression END for_component . RPAREN scope
    RPAREN          shift and go to state 159


state 156

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON ASSIGN expression
    COLON           shift and go to state 160


state 157

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN . expression
    (51) expression -> . comparison_layer
    (52) expression -> . expression OR comparison_layer
    (53) expression -> . expression AND comparison_layer
    (54) comparison_layer -> . arithmetic_layer
    (55) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (56) arithmetic_layer -> . term
    (57) arithmetic_layer -> . arithmetic_layer MINUS term
    (58) arithmetic_layer -> . arithmetic_layer PLUS term
    (59) term -> . factor
    (60) term -> . term DIVISION factor
    (61) term -> . term MULTIPLICATION factor
    (62) factor -> . ID
    (63) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (64) factor -> . value
    (65) factor -> . LPAREN expression RPAREN
    (66) factor -> . function_call
    (74) value -> . STRING_VALUE
    (75) value -> . CHAR_VALUE
    (76) value -> . BOOL_VALUE
    (77) value -> . FLOAT_VALUE
    (78) value -> . INTEGRAL_VALUE
    (11) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 83
    LPAREN          shift and go to state 52
    STRING_VALUE    shift and go to state 64
    CHAR_VALUE      shift and go to state 65
    BOOL_VALUE      shift and go to state 66
    FLOAT_VALUE     shift and go to state 67
    INTEGRAL_VALUE  shift and go to state 58

    expression                     shift and go to state 161
    comparison_layer               shift and go to state 59
    arithmetic_layer               shift and go to state 56
    term                           shift and go to state 60
    factor                         shift and go to state 61
    value                          shift and go to state 62
    function_call                  shift and go to state 63

state 158

    (46) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type .
    END             reduce using rule 46 (array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type .)


state 159

    (39) for_statement -> FOR LPAREN for_component END expression END for_component RPAREN . scope
    (16) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 29

    scope                          shift and go to state 162

state 160

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . ASSIGN expression
    ASSIGN          shift and go to state 157


state 161

    (48) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression .
    (52) expression -> expression . OR comparison_layer
    (53) expression -> expression . AND comparison_layer
    END             reduce using rule 48 (array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression .)
    RPAREN          reduce using rule 48 (array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON ASSIGN expression .)
    OR              shift and go to state 79
    AND             shift and go to state 80


state 162

    (39) for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .
    END             reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    IF              reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    FOR             reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    WHILE           reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    LBRACE          reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    ID              reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    DECLARE         reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    LPAREN          reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    STRING_VALUE    reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    CHAR_VALUE      reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    BOOL_VALUE      reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    FLOAT_VALUE     reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    INTEGRAL_VALUE  reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
    RBRACE          reduce using rule 39 (for_statement -> FOR LPAREN for_component END expression END for_component RPAREN scope .)
