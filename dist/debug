Grammar:

Rule 0     S' -> program
Rule 1     program -> globals
Rule 2     globals -> <empty>
Rule 3     globals -> globall globals
Rule 4     globall -> include
Rule 5     globall -> function
Rule 6     include -> USE STRING_VALUE
Rule 7     include -> INCLUDE SYSTEM_VALUE
Rule 8     include -> INCLUDE STRING_VALUE
Rule 9     function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
Rule 10    formal_params -> <empty>
Rule 11    formal_params -> ID LSBRACKET RSBRACKET COLON type multi_formal_params
Rule 12    formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
Rule 13    formal_params -> ID COLON type multi_formal_params
Rule 14    multi_formal_params -> <empty>
Rule 15    multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
Rule 16    multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
Rule 17    multi_formal_params -> COMMA ID COLON type multi_formal_params
Rule 18    function_call -> ID LPAREN actual_params RPAREN
Rule 19    actual_params -> <empty>
Rule 20    actual_params -> expression multi_actual_params
Rule 21    multi_actual_params -> <empty>
Rule 22    multi_actual_params -> COMMA expression multi_actual_params
Rule 23    scope -> LBRACE new_scope statements pop_scope RBRACE
Rule 24    new_scope -> <empty>
Rule 25    pop_scope -> <empty>
Rule 26    statements -> <empty>
Rule 27    statements -> statement statements
Rule 28    statement -> END
Rule 29    statement -> return_statement
Rule 30    statement -> if_statement
Rule 31    statement -> for_statement
Rule 32    statement -> while_statement
Rule 33    statement -> scope
Rule 34    statement -> array_assignment END
Rule 35    statement -> scalar_assignment END
Rule 36    statement -> array_declaration_init END
Rule 37    statement -> scalar_declaration_init END
Rule 38    statement -> array_declaration END
Rule 39    statement -> scalar_declaration END
Rule 40    statement -> expression END
Rule 41    for_init -> <empty>
Rule 42    for_init -> expression
Rule 43    for_init -> array_assignment
Rule 44    for_init -> array_declaration_init
Rule 45    for_init -> scalar_assignment
Rule 46    for_init -> scalar_declaration_init
Rule 47    for_condition -> <empty>
Rule 48    for_condition -> expression
Rule 49    for_increment -> <empty>
Rule 50    for_increment -> expression
Rule 51    for_increment -> array_assignment
Rule 52    for_increment -> scalar_assignment
Rule 53    for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
Rule 54    while_statement -> WHILE LPAREN expression RPAREN scope
Rule 55    if_statement -> IF LPAREN expression RPAREN scope else_statement
Rule 56    else_statement -> <empty>
Rule 57    else_statement -> ELSE if_statement
Rule 58    else_statement -> ELSE scope
Rule 59    return_statement -> RETURN expression END
Rule 60    scalar_declaration -> DECLARE ID COLON type
Rule 61    array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
Rule 62    scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression
Rule 63    array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
Rule 64    array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
Rule 65    array_init -> LBRACE value multi_array_init RBRACE
Rule 66    multi_array_init -> <empty>
Rule 67    multi_array_init -> COMMA value multi_array_init
Rule 68    scalar_assignment -> ID ASSIGN expression
Rule 69    array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
Rule 70    expression -> comparison_layer
Rule 71    expression -> expression OR comparison_layer
Rule 72    expression -> expression AND comparison_layer
Rule 73    comparison_layer -> arithmetic_layer
Rule 74    comparison_layer -> comparison_layer COMPARATOR arithmetic_layer
Rule 75    arithmetic_layer -> term
Rule 76    arithmetic_layer -> arithmetic_layer MINUS term
Rule 77    arithmetic_layer -> arithmetic_layer PLUS term
Rule 78    term -> factor
Rule 79    term -> term DIVISION factor
Rule 80    term -> term MULTIPLICATION factor
Rule 81    factor -> ID
Rule 82    factor -> ID LSBRACKET arithmetic_layer RSBRACKET
Rule 83    factor -> value
Rule 84    factor -> LPAREN expression RPAREN
Rule 85    factor -> function_call
Rule 86    type -> ABYSS_TYPE
Rule 87    type -> BOOL_TYPE
Rule 88    type -> STRING_TYPE
Rule 89    type -> CHAR_TYPE
Rule 90    type -> FLOAT_TYPE
Rule 91    type -> UNSIGNED_TYPE
Rule 92    type -> SIGNED_TYPE
Rule 93    value -> STRING_VALUE
Rule 94    value -> CHAR_VALUE
Rule 95    value -> BOOL_VALUE
Rule 96    value -> FLOAT_VALUE
Rule 97    value -> INTEGRAL_VALUE

Unused terminals:

    EXTRACTION
    INSERTION

Terminals, with rules where they appear:

ABYSS_TYPE           : 86
AND                  : 72
ASSIGN               : 62 63 64 68 69
BOOL_TYPE            : 87
BOOL_VALUE           : 95
CHAR_TYPE            : 89
CHAR_VALUE           : 94
COLON                : 9 11 12 13 15 16 17 60 61 62 63 64
COMMA                : 15 16 17 22 67
COMPARATOR           : 74
DECLARE              : 60 61 62 63 64
DIVISION             : 79
ELSE                 : 57 58
END                  : 28 34 35 36 37 38 39 40 53 53 59
EXTRACTION           : 
FLOAT_TYPE           : 90
FLOAT_VALUE          : 96
FOR                  : 53
ID                   : 9 11 12 13 15 16 17 18 60 61 62 63 64 68 69 81 82
IF                   : 55
INCLUDE              : 7 8
INSERTION            : 
INTEGRAL_VALUE       : 12 16 61 64 97
LBRACE               : 9 23 53 65
LPAREN               : 9 18 53 54 55 84
LSBRACKET            : 11 12 15 16 61 63 64 69 82
MINUS                : 76
MULTIPLICATION       : 80
OR                   : 71
PLUS                 : 77
RBRACE               : 9 23 53 65
RETURN               : 59
RPAREN               : 9 18 53 54 55 84
RSBRACKET            : 11 12 15 16 61 63 64 69 82
SIGNED_TYPE          : 92
STRING_TYPE          : 88
STRING_VALUE         : 6 8 93
SYSTEM_VALUE         : 7
UNSIGNED_TYPE        : 91
USE                  : 6
WHILE                : 54
error                : 

Nonterminals, with rules where they appear:

actual_params        : 18
arithmetic_layer     : 69 73 74 76 77 82
array_assignment     : 34 43 51
array_declaration    : 38
array_declaration_init : 36 44
array_init           : 63 64
comparison_layer     : 70 71 72 74
else_statement       : 55
expression           : 20 22 40 42 48 50 54 55 59 62 68 69 71 72 84
factor               : 78 79 80
for_condition        : 53
for_increment        : 53
for_init             : 53
for_statement        : 31
formal_params        : 9
function             : 5
function_call        : 85
globall              : 3
globals              : 1 3
if_statement         : 30 57
include              : 4
multi_actual_params  : 20 22
multi_array_init     : 65 67
multi_formal_params  : 11 12 13 15 16 17
new_scope            : 9 23 53
pop_scope            : 9 23 53
program              : 0
return_statement     : 29
scalar_assignment    : 35 45 52
scalar_declaration   : 39
scalar_declaration_init : 37 46
scope                : 33 54 55 58
statement            : 27
statements           : 9 23 27 53
term                 : 75 76 77 79 80
type                 : 9 11 12 13 15 16 17 60 61 62 63 64
value                : 65 67 83
while_statement      : 32


state 0

    (0) S' -> . program
    (1) program -> . globals
    (2) globals -> .
    (3) globals -> . globall globals
    (4) globall -> . include
    (5) globall -> . function
    (6) include -> . USE STRING_VALUE
    (7) include -> . INCLUDE SYSTEM_VALUE
    (8) include -> . INCLUDE STRING_VALUE
    (9) function -> . ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    $end            reduce using rule 2 (globals -> .)
    USE             shift and go to state 6
    INCLUDE         shift and go to state 7
    ID              shift and go to state 8

    program                        shift and go to state 1
    globals                        shift and go to state 2
    globall                        shift and go to state 3
    include                        shift and go to state 4
    function                       shift and go to state 5

state 1

    (0) S' -> program .


state 2

    (1) program -> globals .
    $end            reduce using rule 1 (program -> globals .)


state 3

    (3) globals -> globall . globals
    (2) globals -> .
    (3) globals -> . globall globals
    (4) globall -> . include
    (5) globall -> . function
    (6) include -> . USE STRING_VALUE
    (7) include -> . INCLUDE SYSTEM_VALUE
    (8) include -> . INCLUDE STRING_VALUE
    (9) function -> . ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    $end            reduce using rule 2 (globals -> .)
    USE             shift and go to state 6
    INCLUDE         shift and go to state 7
    ID              shift and go to state 8

    globall                        shift and go to state 3
    globals                        shift and go to state 9
    include                        shift and go to state 4
    function                       shift and go to state 5

state 4

    (4) globall -> include .
    USE             reduce using rule 4 (globall -> include .)
    INCLUDE         reduce using rule 4 (globall -> include .)
    ID              reduce using rule 4 (globall -> include .)
    $end            reduce using rule 4 (globall -> include .)


state 5

    (5) globall -> function .
    USE             reduce using rule 5 (globall -> function .)
    INCLUDE         reduce using rule 5 (globall -> function .)
    ID              reduce using rule 5 (globall -> function .)
    $end            reduce using rule 5 (globall -> function .)


state 6

    (6) include -> USE . STRING_VALUE
    STRING_VALUE    shift and go to state 10


state 7

    (7) include -> INCLUDE . SYSTEM_VALUE
    (8) include -> INCLUDE . STRING_VALUE
    SYSTEM_VALUE    shift and go to state 11
    STRING_VALUE    shift and go to state 12


state 8

    (9) function -> ID . LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    LPAREN          shift and go to state 13


state 9

    (3) globals -> globall globals .
    $end            reduce using rule 3 (globals -> globall globals .)


state 10

    (6) include -> USE STRING_VALUE .
    USE             reduce using rule 6 (include -> USE STRING_VALUE .)
    INCLUDE         reduce using rule 6 (include -> USE STRING_VALUE .)
    ID              reduce using rule 6 (include -> USE STRING_VALUE .)
    $end            reduce using rule 6 (include -> USE STRING_VALUE .)


state 11

    (7) include -> INCLUDE SYSTEM_VALUE .
    USE             reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)
    INCLUDE         reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)
    ID              reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)
    $end            reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)


state 12

    (8) include -> INCLUDE STRING_VALUE .
    USE             reduce using rule 8 (include -> INCLUDE STRING_VALUE .)
    INCLUDE         reduce using rule 8 (include -> INCLUDE STRING_VALUE .)
    ID              reduce using rule 8 (include -> INCLUDE STRING_VALUE .)
    $end            reduce using rule 8 (include -> INCLUDE STRING_VALUE .)


state 13

    (9) function -> ID LPAREN . new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    (24) new_scope -> .
    ID              reduce using rule 24 (new_scope -> .)
    RPAREN          reduce using rule 24 (new_scope -> .)

    new_scope                      shift and go to state 14

state 14

    (9) function -> ID LPAREN new_scope . formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    (10) formal_params -> .
    (11) formal_params -> . ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (12) formal_params -> . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (13) formal_params -> . ID COLON type multi_formal_params
    RPAREN          reduce using rule 10 (formal_params -> .)
    ID              shift and go to state 15

    formal_params                  shift and go to state 16

state 15

    (11) formal_params -> ID . LSBRACKET RSBRACKET COLON type multi_formal_params
    (12) formal_params -> ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (13) formal_params -> ID . COLON type multi_formal_params
    LSBRACKET       shift and go to state 17
    COLON           shift and go to state 18


state 16

    (9) function -> ID LPAREN new_scope formal_params . RPAREN COLON type LBRACE statements pop_scope RBRACE
    RPAREN          shift and go to state 19


state 17

    (11) formal_params -> ID LSBRACKET . RSBRACKET COLON type multi_formal_params
    (12) formal_params -> ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 20
    INTEGRAL_VALUE  shift and go to state 21


state 18

    (13) formal_params -> ID COLON . type multi_formal_params
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 22

state 19

    (9) function -> ID LPAREN new_scope formal_params RPAREN . COLON type LBRACE statements pop_scope RBRACE
    COLON           shift and go to state 30


state 20

    (11) formal_params -> ID LSBRACKET RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 31


state 21

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 32


state 22

    (13) formal_params -> ID COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 34

    multi_formal_params            shift and go to state 33

state 23

    (86) type -> ABYSS_TYPE .
    COMMA           reduce using rule 86 (type -> ABYSS_TYPE .)
    RPAREN          reduce using rule 86 (type -> ABYSS_TYPE .)
    LBRACE          reduce using rule 86 (type -> ABYSS_TYPE .)
    ASSIGN          reduce using rule 86 (type -> ABYSS_TYPE .)
    END             reduce using rule 86 (type -> ABYSS_TYPE .)


state 24

    (87) type -> BOOL_TYPE .
    COMMA           reduce using rule 87 (type -> BOOL_TYPE .)
    RPAREN          reduce using rule 87 (type -> BOOL_TYPE .)
    LBRACE          reduce using rule 87 (type -> BOOL_TYPE .)
    ASSIGN          reduce using rule 87 (type -> BOOL_TYPE .)
    END             reduce using rule 87 (type -> BOOL_TYPE .)


state 25

    (88) type -> STRING_TYPE .
    COMMA           reduce using rule 88 (type -> STRING_TYPE .)
    RPAREN          reduce using rule 88 (type -> STRING_TYPE .)
    LBRACE          reduce using rule 88 (type -> STRING_TYPE .)
    ASSIGN          reduce using rule 88 (type -> STRING_TYPE .)
    END             reduce using rule 88 (type -> STRING_TYPE .)


state 26

    (89) type -> CHAR_TYPE .
    COMMA           reduce using rule 89 (type -> CHAR_TYPE .)
    RPAREN          reduce using rule 89 (type -> CHAR_TYPE .)
    LBRACE          reduce using rule 89 (type -> CHAR_TYPE .)
    ASSIGN          reduce using rule 89 (type -> CHAR_TYPE .)
    END             reduce using rule 89 (type -> CHAR_TYPE .)


state 27

    (90) type -> FLOAT_TYPE .
    COMMA           reduce using rule 90 (type -> FLOAT_TYPE .)
    RPAREN          reduce using rule 90 (type -> FLOAT_TYPE .)
    LBRACE          reduce using rule 90 (type -> FLOAT_TYPE .)
    ASSIGN          reduce using rule 90 (type -> FLOAT_TYPE .)
    END             reduce using rule 90 (type -> FLOAT_TYPE .)


state 28

    (91) type -> UNSIGNED_TYPE .
    COMMA           reduce using rule 91 (type -> UNSIGNED_TYPE .)
    RPAREN          reduce using rule 91 (type -> UNSIGNED_TYPE .)
    LBRACE          reduce using rule 91 (type -> UNSIGNED_TYPE .)
    ASSIGN          reduce using rule 91 (type -> UNSIGNED_TYPE .)
    END             reduce using rule 91 (type -> UNSIGNED_TYPE .)


state 29

    (92) type -> SIGNED_TYPE .
    COMMA           reduce using rule 92 (type -> SIGNED_TYPE .)
    RPAREN          reduce using rule 92 (type -> SIGNED_TYPE .)
    LBRACE          reduce using rule 92 (type -> SIGNED_TYPE .)
    ASSIGN          reduce using rule 92 (type -> SIGNED_TYPE .)
    END             reduce using rule 92 (type -> SIGNED_TYPE .)


state 30

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON . type LBRACE statements pop_scope RBRACE
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 35

state 31

    (11) formal_params -> ID LSBRACKET RSBRACKET COLON . type multi_formal_params
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 36

state 32

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 37


state 33

    (13) formal_params -> ID COLON type multi_formal_params .
    RPAREN          reduce using rule 13 (formal_params -> ID COLON type multi_formal_params .)


state 34

    (15) multi_formal_params -> COMMA . ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> COMMA . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> COMMA . ID COLON type multi_formal_params
    ID              shift and go to state 38


state 35

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type . LBRACE statements pop_scope RBRACE
    LBRACE          shift and go to state 39


state 36

    (11) formal_params -> ID LSBRACKET RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 34

    multi_formal_params            shift and go to state 40

state 37

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type multi_formal_params
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 41

state 38

    (15) multi_formal_params -> COMMA ID . LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> COMMA ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> COMMA ID . COLON type multi_formal_params
    LSBRACKET       shift and go to state 42
    COLON           shift and go to state 43


state 39

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE . statements pop_scope RBRACE
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . return_statement
    (30) statement -> . if_statement
    (31) statement -> . for_statement
    (32) statement -> . while_statement
    (33) statement -> . scope
    (34) statement -> . array_assignment END
    (35) statement -> . scalar_assignment END
    (36) statement -> . array_declaration_init END
    (37) statement -> . scalar_declaration_init END
    (38) statement -> . array_declaration END
    (39) statement -> . scalar_declaration END
    (40) statement -> . expression END
    (59) return_statement -> . RETURN expression END
    (55) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (53) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (54) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (69) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (68) scalar_assignment -> . ID ASSIGN expression
    (63) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (61) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (60) scalar_declaration -> . DECLARE ID COLON type
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 49
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 64
    WHILE           shift and go to state 65
    LBRACE          shift and go to state 46
    ID              shift and go to state 44
    DECLARE         shift and go to state 67
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    statements                     shift and go to state 47
    statement                      shift and go to state 48
    return_statement               shift and go to state 50
    if_statement                   shift and go to state 51
    for_statement                  shift and go to state 52
    while_statement                shift and go to state 53
    scope                          shift and go to state 54
    array_assignment               shift and go to state 55
    scalar_assignment              shift and go to state 56
    array_declaration_init         shift and go to state 57
    scalar_declaration_init        shift and go to state 58
    array_declaration              shift and go to state 59
    scalar_declaration             shift and go to state 60
    expression                     shift and go to state 61
    arithmetic_layer               shift and go to state 66
    comparison_layer               shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 40

    (11) formal_params -> ID LSBRACKET RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 11 (formal_params -> ID LSBRACKET RSBRACKET COLON type multi_formal_params .)


state 41

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 34

    multi_formal_params            shift and go to state 78

state 42

    (15) multi_formal_params -> COMMA ID LSBRACKET . RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> COMMA ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 80


state 43

    (17) multi_formal_params -> COMMA ID COLON . type multi_formal_params
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 81

state 44

    (69) array_assignment -> ID . LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (68) scalar_assignment -> ID . ASSIGN expression
    (81) factor -> ID .
    (82) factor -> ID . LSBRACKET arithmetic_layer RSBRACKET
    (18) function_call -> ID . LPAREN actual_params RPAREN
    LSBRACKET       shift and go to state 82
    ASSIGN          shift and go to state 83
    DIVISION        reduce using rule 81 (factor -> ID .)
    MULTIPLICATION  reduce using rule 81 (factor -> ID .)
    MINUS           reduce using rule 81 (factor -> ID .)
    PLUS            reduce using rule 81 (factor -> ID .)
    COMPARATOR      reduce using rule 81 (factor -> ID .)
    END             reduce using rule 81 (factor -> ID .)
    OR              reduce using rule 81 (factor -> ID .)
    AND             reduce using rule 81 (factor -> ID .)
    RPAREN          reduce using rule 81 (factor -> ID .)
    LPAREN          shift and go to state 84


state 45

    (84) factor -> LPAREN . expression RPAREN
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    expression                     shift and go to state 85
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 46

    (23) scope -> LBRACE . new_scope statements pop_scope RBRACE
    (24) new_scope -> .
    END             reduce using rule 24 (new_scope -> .)
    RETURN          reduce using rule 24 (new_scope -> .)
    IF              reduce using rule 24 (new_scope -> .)
    FOR             reduce using rule 24 (new_scope -> .)
    WHILE           reduce using rule 24 (new_scope -> .)
    LBRACE          reduce using rule 24 (new_scope -> .)
    ID              reduce using rule 24 (new_scope -> .)
    DECLARE         reduce using rule 24 (new_scope -> .)
    LPAREN          reduce using rule 24 (new_scope -> .)
    STRING_VALUE    reduce using rule 24 (new_scope -> .)
    CHAR_VALUE      reduce using rule 24 (new_scope -> .)
    BOOL_VALUE      reduce using rule 24 (new_scope -> .)
    FLOAT_VALUE     reduce using rule 24 (new_scope -> .)
    INTEGRAL_VALUE  reduce using rule 24 (new_scope -> .)
    RBRACE          reduce using rule 24 (new_scope -> .)

    new_scope                      shift and go to state 87

state 47

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements . pop_scope RBRACE
    (25) pop_scope -> .
    RBRACE          reduce using rule 25 (pop_scope -> .)

    pop_scope                      shift and go to state 88

state 48

    (27) statements -> statement . statements
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . return_statement
    (30) statement -> . if_statement
    (31) statement -> . for_statement
    (32) statement -> . while_statement
    (33) statement -> . scope
    (34) statement -> . array_assignment END
    (35) statement -> . scalar_assignment END
    (36) statement -> . array_declaration_init END
    (37) statement -> . scalar_declaration_init END
    (38) statement -> . array_declaration END
    (39) statement -> . scalar_declaration END
    (40) statement -> . expression END
    (59) return_statement -> . RETURN expression END
    (55) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (53) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (54) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (69) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (68) scalar_assignment -> . ID ASSIGN expression
    (63) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (61) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (60) scalar_declaration -> . DECLARE ID COLON type
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 49
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 64
    WHILE           shift and go to state 65
    LBRACE          shift and go to state 46
    ID              shift and go to state 44
    DECLARE         shift and go to state 67
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    statement                      shift and go to state 48
    statements                     shift and go to state 89
    return_statement               shift and go to state 50
    if_statement                   shift and go to state 51
    for_statement                  shift and go to state 52
    while_statement                shift and go to state 53
    scope                          shift and go to state 54
    array_assignment               shift and go to state 55
    scalar_assignment              shift and go to state 56
    array_declaration_init         shift and go to state 57
    scalar_declaration_init        shift and go to state 58
    array_declaration              shift and go to state 59
    scalar_declaration             shift and go to state 60
    expression                     shift and go to state 61
    arithmetic_layer               shift and go to state 66
    comparison_layer               shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 49

    (28) statement -> END .
    END             reduce using rule 28 (statement -> END .)
    RETURN          reduce using rule 28 (statement -> END .)
    IF              reduce using rule 28 (statement -> END .)
    FOR             reduce using rule 28 (statement -> END .)
    WHILE           reduce using rule 28 (statement -> END .)
    LBRACE          reduce using rule 28 (statement -> END .)
    ID              reduce using rule 28 (statement -> END .)
    DECLARE         reduce using rule 28 (statement -> END .)
    LPAREN          reduce using rule 28 (statement -> END .)
    STRING_VALUE    reduce using rule 28 (statement -> END .)
    CHAR_VALUE      reduce using rule 28 (statement -> END .)
    BOOL_VALUE      reduce using rule 28 (statement -> END .)
    FLOAT_VALUE     reduce using rule 28 (statement -> END .)
    INTEGRAL_VALUE  reduce using rule 28 (statement -> END .)
    RBRACE          reduce using rule 28 (statement -> END .)


state 50

    (29) statement -> return_statement .
    END             reduce using rule 29 (statement -> return_statement .)
    RETURN          reduce using rule 29 (statement -> return_statement .)
    IF              reduce using rule 29 (statement -> return_statement .)
    FOR             reduce using rule 29 (statement -> return_statement .)
    WHILE           reduce using rule 29 (statement -> return_statement .)
    LBRACE          reduce using rule 29 (statement -> return_statement .)
    ID              reduce using rule 29 (statement -> return_statement .)
    DECLARE         reduce using rule 29 (statement -> return_statement .)
    LPAREN          reduce using rule 29 (statement -> return_statement .)
    STRING_VALUE    reduce using rule 29 (statement -> return_statement .)
    CHAR_VALUE      reduce using rule 29 (statement -> return_statement .)
    BOOL_VALUE      reduce using rule 29 (statement -> return_statement .)
    FLOAT_VALUE     reduce using rule 29 (statement -> return_statement .)
    INTEGRAL_VALUE  reduce using rule 29 (statement -> return_statement .)
    RBRACE          reduce using rule 29 (statement -> return_statement .)


state 51

    (30) statement -> if_statement .
    END             reduce using rule 30 (statement -> if_statement .)
    RETURN          reduce using rule 30 (statement -> if_statement .)
    IF              reduce using rule 30 (statement -> if_statement .)
    FOR             reduce using rule 30 (statement -> if_statement .)
    WHILE           reduce using rule 30 (statement -> if_statement .)
    LBRACE          reduce using rule 30 (statement -> if_statement .)
    ID              reduce using rule 30 (statement -> if_statement .)
    DECLARE         reduce using rule 30 (statement -> if_statement .)
    LPAREN          reduce using rule 30 (statement -> if_statement .)
    STRING_VALUE    reduce using rule 30 (statement -> if_statement .)
    CHAR_VALUE      reduce using rule 30 (statement -> if_statement .)
    BOOL_VALUE      reduce using rule 30 (statement -> if_statement .)
    FLOAT_VALUE     reduce using rule 30 (statement -> if_statement .)
    INTEGRAL_VALUE  reduce using rule 30 (statement -> if_statement .)
    RBRACE          reduce using rule 30 (statement -> if_statement .)


state 52

    (31) statement -> for_statement .
    END             reduce using rule 31 (statement -> for_statement .)
    RETURN          reduce using rule 31 (statement -> for_statement .)
    IF              reduce using rule 31 (statement -> for_statement .)
    FOR             reduce using rule 31 (statement -> for_statement .)
    WHILE           reduce using rule 31 (statement -> for_statement .)
    LBRACE          reduce using rule 31 (statement -> for_statement .)
    ID              reduce using rule 31 (statement -> for_statement .)
    DECLARE         reduce using rule 31 (statement -> for_statement .)
    LPAREN          reduce using rule 31 (statement -> for_statement .)
    STRING_VALUE    reduce using rule 31 (statement -> for_statement .)
    CHAR_VALUE      reduce using rule 31 (statement -> for_statement .)
    BOOL_VALUE      reduce using rule 31 (statement -> for_statement .)
    FLOAT_VALUE     reduce using rule 31 (statement -> for_statement .)
    INTEGRAL_VALUE  reduce using rule 31 (statement -> for_statement .)
    RBRACE          reduce using rule 31 (statement -> for_statement .)


state 53

    (32) statement -> while_statement .
    END             reduce using rule 32 (statement -> while_statement .)
    RETURN          reduce using rule 32 (statement -> while_statement .)
    IF              reduce using rule 32 (statement -> while_statement .)
    FOR             reduce using rule 32 (statement -> while_statement .)
    WHILE           reduce using rule 32 (statement -> while_statement .)
    LBRACE          reduce using rule 32 (statement -> while_statement .)
    ID              reduce using rule 32 (statement -> while_statement .)
    DECLARE         reduce using rule 32 (statement -> while_statement .)
    LPAREN          reduce using rule 32 (statement -> while_statement .)
    STRING_VALUE    reduce using rule 32 (statement -> while_statement .)
    CHAR_VALUE      reduce using rule 32 (statement -> while_statement .)
    BOOL_VALUE      reduce using rule 32 (statement -> while_statement .)
    FLOAT_VALUE     reduce using rule 32 (statement -> while_statement .)
    INTEGRAL_VALUE  reduce using rule 32 (statement -> while_statement .)
    RBRACE          reduce using rule 32 (statement -> while_statement .)


state 54

    (33) statement -> scope .
    END             reduce using rule 33 (statement -> scope .)
    RETURN          reduce using rule 33 (statement -> scope .)
    IF              reduce using rule 33 (statement -> scope .)
    FOR             reduce using rule 33 (statement -> scope .)
    WHILE           reduce using rule 33 (statement -> scope .)
    LBRACE          reduce using rule 33 (statement -> scope .)
    ID              reduce using rule 33 (statement -> scope .)
    DECLARE         reduce using rule 33 (statement -> scope .)
    LPAREN          reduce using rule 33 (statement -> scope .)
    STRING_VALUE    reduce using rule 33 (statement -> scope .)
    CHAR_VALUE      reduce using rule 33 (statement -> scope .)
    BOOL_VALUE      reduce using rule 33 (statement -> scope .)
    FLOAT_VALUE     reduce using rule 33 (statement -> scope .)
    INTEGRAL_VALUE  reduce using rule 33 (statement -> scope .)
    RBRACE          reduce using rule 33 (statement -> scope .)


state 55

    (34) statement -> array_assignment . END
    END             shift and go to state 90


state 56

    (35) statement -> scalar_assignment . END
    END             shift and go to state 91


state 57

    (36) statement -> array_declaration_init . END
    END             shift and go to state 92


state 58

    (37) statement -> scalar_declaration_init . END
    END             shift and go to state 93


state 59

    (38) statement -> array_declaration . END
    END             shift and go to state 94


state 60

    (39) statement -> scalar_declaration . END
    END             shift and go to state 95


state 61

    (40) statement -> expression . END
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    END             shift and go to state 96
    OR              shift and go to state 97
    AND             shift and go to state 98


state 62

    (59) return_statement -> RETURN . expression END
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    expression                     shift and go to state 99
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 63

    (55) if_statement -> IF . LPAREN expression RPAREN scope else_statement
    LPAREN          shift and go to state 100


state 64

    (53) for_statement -> FOR . LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    LPAREN          shift and go to state 101


state 65

    (54) while_statement -> WHILE . LPAREN expression RPAREN scope
    LPAREN          shift and go to state 102


state 66

    (73) comparison_layer -> arithmetic_layer .
    (76) arithmetic_layer -> arithmetic_layer . MINUS term
    (77) arithmetic_layer -> arithmetic_layer . PLUS term
    COMPARATOR      reduce using rule 73 (comparison_layer -> arithmetic_layer .)
    END             reduce using rule 73 (comparison_layer -> arithmetic_layer .)
    OR              reduce using rule 73 (comparison_layer -> arithmetic_layer .)
    AND             reduce using rule 73 (comparison_layer -> arithmetic_layer .)
    RPAREN          reduce using rule 73 (comparison_layer -> arithmetic_layer .)
    COMMA           reduce using rule 73 (comparison_layer -> arithmetic_layer .)
    MINUS           shift and go to state 103
    PLUS            shift and go to state 104


state 67

    (63) array_declaration_init -> DECLARE . ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> DECLARE . ID COLON type ASSIGN expression
    (61) array_declaration -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (60) scalar_declaration -> DECLARE . ID COLON type
    ID              shift and go to state 105


state 68

    (97) value -> INTEGRAL_VALUE .
    DIVISION        reduce using rule 97 (value -> INTEGRAL_VALUE .)
    MULTIPLICATION  reduce using rule 97 (value -> INTEGRAL_VALUE .)
    MINUS           reduce using rule 97 (value -> INTEGRAL_VALUE .)
    PLUS            reduce using rule 97 (value -> INTEGRAL_VALUE .)
    COMPARATOR      reduce using rule 97 (value -> INTEGRAL_VALUE .)
    END             reduce using rule 97 (value -> INTEGRAL_VALUE .)
    OR              reduce using rule 97 (value -> INTEGRAL_VALUE .)
    AND             reduce using rule 97 (value -> INTEGRAL_VALUE .)
    RPAREN          reduce using rule 97 (value -> INTEGRAL_VALUE .)
    RSBRACKET       reduce using rule 97 (value -> INTEGRAL_VALUE .)
    COMMA           reduce using rule 97 (value -> INTEGRAL_VALUE .)
    RBRACE          reduce using rule 97 (value -> INTEGRAL_VALUE .)


state 69

    (70) expression -> comparison_layer .
    (74) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 70 (expression -> comparison_layer .)
    OR              reduce using rule 70 (expression -> comparison_layer .)
    AND             reduce using rule 70 (expression -> comparison_layer .)
    RPAREN          reduce using rule 70 (expression -> comparison_layer .)
    COMMA           reduce using rule 70 (expression -> comparison_layer .)
    COMPARATOR      shift and go to state 106


state 70

    (75) arithmetic_layer -> term .
    (79) term -> term . DIVISION factor
    (80) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 75 (arithmetic_layer -> term .)
    PLUS            reduce using rule 75 (arithmetic_layer -> term .)
    COMPARATOR      reduce using rule 75 (arithmetic_layer -> term .)
    END             reduce using rule 75 (arithmetic_layer -> term .)
    OR              reduce using rule 75 (arithmetic_layer -> term .)
    AND             reduce using rule 75 (arithmetic_layer -> term .)
    RPAREN          reduce using rule 75 (arithmetic_layer -> term .)
    RSBRACKET       reduce using rule 75 (arithmetic_layer -> term .)
    COMMA           reduce using rule 75 (arithmetic_layer -> term .)
    DIVISION        shift and go to state 107
    MULTIPLICATION  shift and go to state 108


state 71

    (78) term -> factor .
    DIVISION        reduce using rule 78 (term -> factor .)
    MULTIPLICATION  reduce using rule 78 (term -> factor .)
    MINUS           reduce using rule 78 (term -> factor .)
    PLUS            reduce using rule 78 (term -> factor .)
    COMPARATOR      reduce using rule 78 (term -> factor .)
    END             reduce using rule 78 (term -> factor .)
    OR              reduce using rule 78 (term -> factor .)
    AND             reduce using rule 78 (term -> factor .)
    RPAREN          reduce using rule 78 (term -> factor .)
    RSBRACKET       reduce using rule 78 (term -> factor .)
    COMMA           reduce using rule 78 (term -> factor .)


state 72

    (83) factor -> value .
    DIVISION        reduce using rule 83 (factor -> value .)
    MULTIPLICATION  reduce using rule 83 (factor -> value .)
    MINUS           reduce using rule 83 (factor -> value .)
    PLUS            reduce using rule 83 (factor -> value .)
    COMPARATOR      reduce using rule 83 (factor -> value .)
    END             reduce using rule 83 (factor -> value .)
    OR              reduce using rule 83 (factor -> value .)
    AND             reduce using rule 83 (factor -> value .)
    RPAREN          reduce using rule 83 (factor -> value .)
    RSBRACKET       reduce using rule 83 (factor -> value .)
    COMMA           reduce using rule 83 (factor -> value .)


state 73

    (85) factor -> function_call .
    DIVISION        reduce using rule 85 (factor -> function_call .)
    MULTIPLICATION  reduce using rule 85 (factor -> function_call .)
    MINUS           reduce using rule 85 (factor -> function_call .)
    PLUS            reduce using rule 85 (factor -> function_call .)
    COMPARATOR      reduce using rule 85 (factor -> function_call .)
    END             reduce using rule 85 (factor -> function_call .)
    OR              reduce using rule 85 (factor -> function_call .)
    AND             reduce using rule 85 (factor -> function_call .)
    RPAREN          reduce using rule 85 (factor -> function_call .)
    RSBRACKET       reduce using rule 85 (factor -> function_call .)
    COMMA           reduce using rule 85 (factor -> function_call .)


state 74

    (93) value -> STRING_VALUE .
    DIVISION        reduce using rule 93 (value -> STRING_VALUE .)
    MULTIPLICATION  reduce using rule 93 (value -> STRING_VALUE .)
    MINUS           reduce using rule 93 (value -> STRING_VALUE .)
    PLUS            reduce using rule 93 (value -> STRING_VALUE .)
    COMPARATOR      reduce using rule 93 (value -> STRING_VALUE .)
    END             reduce using rule 93 (value -> STRING_VALUE .)
    OR              reduce using rule 93 (value -> STRING_VALUE .)
    AND             reduce using rule 93 (value -> STRING_VALUE .)
    RPAREN          reduce using rule 93 (value -> STRING_VALUE .)
    RSBRACKET       reduce using rule 93 (value -> STRING_VALUE .)
    COMMA           reduce using rule 93 (value -> STRING_VALUE .)
    RBRACE          reduce using rule 93 (value -> STRING_VALUE .)


state 75

    (94) value -> CHAR_VALUE .
    DIVISION        reduce using rule 94 (value -> CHAR_VALUE .)
    MULTIPLICATION  reduce using rule 94 (value -> CHAR_VALUE .)
    MINUS           reduce using rule 94 (value -> CHAR_VALUE .)
    PLUS            reduce using rule 94 (value -> CHAR_VALUE .)
    COMPARATOR      reduce using rule 94 (value -> CHAR_VALUE .)
    END             reduce using rule 94 (value -> CHAR_VALUE .)
    OR              reduce using rule 94 (value -> CHAR_VALUE .)
    AND             reduce using rule 94 (value -> CHAR_VALUE .)
    RPAREN          reduce using rule 94 (value -> CHAR_VALUE .)
    RSBRACKET       reduce using rule 94 (value -> CHAR_VALUE .)
    COMMA           reduce using rule 94 (value -> CHAR_VALUE .)
    RBRACE          reduce using rule 94 (value -> CHAR_VALUE .)


state 76

    (95) value -> BOOL_VALUE .
    DIVISION        reduce using rule 95 (value -> BOOL_VALUE .)
    MULTIPLICATION  reduce using rule 95 (value -> BOOL_VALUE .)
    MINUS           reduce using rule 95 (value -> BOOL_VALUE .)
    PLUS            reduce using rule 95 (value -> BOOL_VALUE .)
    COMPARATOR      reduce using rule 95 (value -> BOOL_VALUE .)
    END             reduce using rule 95 (value -> BOOL_VALUE .)
    OR              reduce using rule 95 (value -> BOOL_VALUE .)
    AND             reduce using rule 95 (value -> BOOL_VALUE .)
    RPAREN          reduce using rule 95 (value -> BOOL_VALUE .)
    RSBRACKET       reduce using rule 95 (value -> BOOL_VALUE .)
    COMMA           reduce using rule 95 (value -> BOOL_VALUE .)
    RBRACE          reduce using rule 95 (value -> BOOL_VALUE .)


state 77

    (96) value -> FLOAT_VALUE .
    DIVISION        reduce using rule 96 (value -> FLOAT_VALUE .)
    MULTIPLICATION  reduce using rule 96 (value -> FLOAT_VALUE .)
    MINUS           reduce using rule 96 (value -> FLOAT_VALUE .)
    PLUS            reduce using rule 96 (value -> FLOAT_VALUE .)
    COMPARATOR      reduce using rule 96 (value -> FLOAT_VALUE .)
    END             reduce using rule 96 (value -> FLOAT_VALUE .)
    OR              reduce using rule 96 (value -> FLOAT_VALUE .)
    AND             reduce using rule 96 (value -> FLOAT_VALUE .)
    RPAREN          reduce using rule 96 (value -> FLOAT_VALUE .)
    RSBRACKET       reduce using rule 96 (value -> FLOAT_VALUE .)
    COMMA           reduce using rule 96 (value -> FLOAT_VALUE .)
    RBRACE          reduce using rule 96 (value -> FLOAT_VALUE .)


state 78

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 12 (formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .)


state 79

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 109


state 80

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 110


state 81

    (17) multi_formal_params -> COMMA ID COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 34

    multi_formal_params            shift and go to state 111

state 82

    (69) array_assignment -> ID LSBRACKET . arithmetic_layer RSBRACKET ASSIGN expression
    (82) factor -> ID LSBRACKET . arithmetic_layer RSBRACKET
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    arithmetic_layer               shift and go to state 112
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 83

    (68) scalar_assignment -> ID ASSIGN . expression
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    expression                     shift and go to state 113
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 84

    (18) function_call -> ID LPAREN . actual_params RPAREN
    (19) actual_params -> .
    (20) actual_params -> . expression multi_actual_params
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RPAREN          reduce using rule 19 (actual_params -> .)
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    actual_params                  shift and go to state 114
    expression                     shift and go to state 115
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 85

    (84) factor -> LPAREN expression . RPAREN
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 116
    OR              shift and go to state 97
    AND             shift and go to state 98


state 86

    (81) factor -> ID .
    (82) factor -> ID . LSBRACKET arithmetic_layer RSBRACKET
    (18) function_call -> ID . LPAREN actual_params RPAREN
    DIVISION        reduce using rule 81 (factor -> ID .)
    MULTIPLICATION  reduce using rule 81 (factor -> ID .)
    MINUS           reduce using rule 81 (factor -> ID .)
    PLUS            reduce using rule 81 (factor -> ID .)
    COMPARATOR      reduce using rule 81 (factor -> ID .)
    RPAREN          reduce using rule 81 (factor -> ID .)
    OR              reduce using rule 81 (factor -> ID .)
    AND             reduce using rule 81 (factor -> ID .)
    END             reduce using rule 81 (factor -> ID .)
    RSBRACKET       reduce using rule 81 (factor -> ID .)
    COMMA           reduce using rule 81 (factor -> ID .)
    LSBRACKET       shift and go to state 117
    LPAREN          shift and go to state 84


state 87

    (23) scope -> LBRACE new_scope . statements pop_scope RBRACE
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . return_statement
    (30) statement -> . if_statement
    (31) statement -> . for_statement
    (32) statement -> . while_statement
    (33) statement -> . scope
    (34) statement -> . array_assignment END
    (35) statement -> . scalar_assignment END
    (36) statement -> . array_declaration_init END
    (37) statement -> . scalar_declaration_init END
    (38) statement -> . array_declaration END
    (39) statement -> . scalar_declaration END
    (40) statement -> . expression END
    (59) return_statement -> . RETURN expression END
    (55) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (53) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (54) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (69) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (68) scalar_assignment -> . ID ASSIGN expression
    (63) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (61) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (60) scalar_declaration -> . DECLARE ID COLON type
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 49
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 64
    WHILE           shift and go to state 65
    LBRACE          shift and go to state 46
    ID              shift and go to state 44
    DECLARE         shift and go to state 67
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    statements                     shift and go to state 118
    statement                      shift and go to state 48
    return_statement               shift and go to state 50
    if_statement                   shift and go to state 51
    for_statement                  shift and go to state 52
    while_statement                shift and go to state 53
    scope                          shift and go to state 54
    array_assignment               shift and go to state 55
    scalar_assignment              shift and go to state 56
    array_declaration_init         shift and go to state 57
    scalar_declaration_init        shift and go to state 58
    array_declaration              shift and go to state 59
    scalar_declaration             shift and go to state 60
    expression                     shift and go to state 61
    arithmetic_layer               shift and go to state 66
    comparison_layer               shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 88

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope . RBRACE
    RBRACE          shift and go to state 119


state 89

    (27) statements -> statement statements .
    RBRACE          reduce using rule 27 (statements -> statement statements .)


state 90

    (34) statement -> array_assignment END .
    END             reduce using rule 34 (statement -> array_assignment END .)
    RETURN          reduce using rule 34 (statement -> array_assignment END .)
    IF              reduce using rule 34 (statement -> array_assignment END .)
    FOR             reduce using rule 34 (statement -> array_assignment END .)
    WHILE           reduce using rule 34 (statement -> array_assignment END .)
    LBRACE          reduce using rule 34 (statement -> array_assignment END .)
    ID              reduce using rule 34 (statement -> array_assignment END .)
    DECLARE         reduce using rule 34 (statement -> array_assignment END .)
    LPAREN          reduce using rule 34 (statement -> array_assignment END .)
    STRING_VALUE    reduce using rule 34 (statement -> array_assignment END .)
    CHAR_VALUE      reduce using rule 34 (statement -> array_assignment END .)
    BOOL_VALUE      reduce using rule 34 (statement -> array_assignment END .)
    FLOAT_VALUE     reduce using rule 34 (statement -> array_assignment END .)
    INTEGRAL_VALUE  reduce using rule 34 (statement -> array_assignment END .)
    RBRACE          reduce using rule 34 (statement -> array_assignment END .)


state 91

    (35) statement -> scalar_assignment END .
    END             reduce using rule 35 (statement -> scalar_assignment END .)
    RETURN          reduce using rule 35 (statement -> scalar_assignment END .)
    IF              reduce using rule 35 (statement -> scalar_assignment END .)
    FOR             reduce using rule 35 (statement -> scalar_assignment END .)
    WHILE           reduce using rule 35 (statement -> scalar_assignment END .)
    LBRACE          reduce using rule 35 (statement -> scalar_assignment END .)
    ID              reduce using rule 35 (statement -> scalar_assignment END .)
    DECLARE         reduce using rule 35 (statement -> scalar_assignment END .)
    LPAREN          reduce using rule 35 (statement -> scalar_assignment END .)
    STRING_VALUE    reduce using rule 35 (statement -> scalar_assignment END .)
    CHAR_VALUE      reduce using rule 35 (statement -> scalar_assignment END .)
    BOOL_VALUE      reduce using rule 35 (statement -> scalar_assignment END .)
    FLOAT_VALUE     reduce using rule 35 (statement -> scalar_assignment END .)
    INTEGRAL_VALUE  reduce using rule 35 (statement -> scalar_assignment END .)
    RBRACE          reduce using rule 35 (statement -> scalar_assignment END .)


state 92

    (36) statement -> array_declaration_init END .
    END             reduce using rule 36 (statement -> array_declaration_init END .)
    RETURN          reduce using rule 36 (statement -> array_declaration_init END .)
    IF              reduce using rule 36 (statement -> array_declaration_init END .)
    FOR             reduce using rule 36 (statement -> array_declaration_init END .)
    WHILE           reduce using rule 36 (statement -> array_declaration_init END .)
    LBRACE          reduce using rule 36 (statement -> array_declaration_init END .)
    ID              reduce using rule 36 (statement -> array_declaration_init END .)
    DECLARE         reduce using rule 36 (statement -> array_declaration_init END .)
    LPAREN          reduce using rule 36 (statement -> array_declaration_init END .)
    STRING_VALUE    reduce using rule 36 (statement -> array_declaration_init END .)
    CHAR_VALUE      reduce using rule 36 (statement -> array_declaration_init END .)
    BOOL_VALUE      reduce using rule 36 (statement -> array_declaration_init END .)
    FLOAT_VALUE     reduce using rule 36 (statement -> array_declaration_init END .)
    INTEGRAL_VALUE  reduce using rule 36 (statement -> array_declaration_init END .)
    RBRACE          reduce using rule 36 (statement -> array_declaration_init END .)


state 93

    (37) statement -> scalar_declaration_init END .
    END             reduce using rule 37 (statement -> scalar_declaration_init END .)
    RETURN          reduce using rule 37 (statement -> scalar_declaration_init END .)
    IF              reduce using rule 37 (statement -> scalar_declaration_init END .)
    FOR             reduce using rule 37 (statement -> scalar_declaration_init END .)
    WHILE           reduce using rule 37 (statement -> scalar_declaration_init END .)
    LBRACE          reduce using rule 37 (statement -> scalar_declaration_init END .)
    ID              reduce using rule 37 (statement -> scalar_declaration_init END .)
    DECLARE         reduce using rule 37 (statement -> scalar_declaration_init END .)
    LPAREN          reduce using rule 37 (statement -> scalar_declaration_init END .)
    STRING_VALUE    reduce using rule 37 (statement -> scalar_declaration_init END .)
    CHAR_VALUE      reduce using rule 37 (statement -> scalar_declaration_init END .)
    BOOL_VALUE      reduce using rule 37 (statement -> scalar_declaration_init END .)
    FLOAT_VALUE     reduce using rule 37 (statement -> scalar_declaration_init END .)
    INTEGRAL_VALUE  reduce using rule 37 (statement -> scalar_declaration_init END .)
    RBRACE          reduce using rule 37 (statement -> scalar_declaration_init END .)


state 94

    (38) statement -> array_declaration END .
    END             reduce using rule 38 (statement -> array_declaration END .)
    RETURN          reduce using rule 38 (statement -> array_declaration END .)
    IF              reduce using rule 38 (statement -> array_declaration END .)
    FOR             reduce using rule 38 (statement -> array_declaration END .)
    WHILE           reduce using rule 38 (statement -> array_declaration END .)
    LBRACE          reduce using rule 38 (statement -> array_declaration END .)
    ID              reduce using rule 38 (statement -> array_declaration END .)
    DECLARE         reduce using rule 38 (statement -> array_declaration END .)
    LPAREN          reduce using rule 38 (statement -> array_declaration END .)
    STRING_VALUE    reduce using rule 38 (statement -> array_declaration END .)
    CHAR_VALUE      reduce using rule 38 (statement -> array_declaration END .)
    BOOL_VALUE      reduce using rule 38 (statement -> array_declaration END .)
    FLOAT_VALUE     reduce using rule 38 (statement -> array_declaration END .)
    INTEGRAL_VALUE  reduce using rule 38 (statement -> array_declaration END .)
    RBRACE          reduce using rule 38 (statement -> array_declaration END .)


state 95

    (39) statement -> scalar_declaration END .
    END             reduce using rule 39 (statement -> scalar_declaration END .)
    RETURN          reduce using rule 39 (statement -> scalar_declaration END .)
    IF              reduce using rule 39 (statement -> scalar_declaration END .)
    FOR             reduce using rule 39 (statement -> scalar_declaration END .)
    WHILE           reduce using rule 39 (statement -> scalar_declaration END .)
    LBRACE          reduce using rule 39 (statement -> scalar_declaration END .)
    ID              reduce using rule 39 (statement -> scalar_declaration END .)
    DECLARE         reduce using rule 39 (statement -> scalar_declaration END .)
    LPAREN          reduce using rule 39 (statement -> scalar_declaration END .)
    STRING_VALUE    reduce using rule 39 (statement -> scalar_declaration END .)
    CHAR_VALUE      reduce using rule 39 (statement -> scalar_declaration END .)
    BOOL_VALUE      reduce using rule 39 (statement -> scalar_declaration END .)
    FLOAT_VALUE     reduce using rule 39 (statement -> scalar_declaration END .)
    INTEGRAL_VALUE  reduce using rule 39 (statement -> scalar_declaration END .)
    RBRACE          reduce using rule 39 (statement -> scalar_declaration END .)


state 96

    (40) statement -> expression END .
    END             reduce using rule 40 (statement -> expression END .)
    RETURN          reduce using rule 40 (statement -> expression END .)
    IF              reduce using rule 40 (statement -> expression END .)
    FOR             reduce using rule 40 (statement -> expression END .)
    WHILE           reduce using rule 40 (statement -> expression END .)
    LBRACE          reduce using rule 40 (statement -> expression END .)
    ID              reduce using rule 40 (statement -> expression END .)
    DECLARE         reduce using rule 40 (statement -> expression END .)
    LPAREN          reduce using rule 40 (statement -> expression END .)
    STRING_VALUE    reduce using rule 40 (statement -> expression END .)
    CHAR_VALUE      reduce using rule 40 (statement -> expression END .)
    BOOL_VALUE      reduce using rule 40 (statement -> expression END .)
    FLOAT_VALUE     reduce using rule 40 (statement -> expression END .)
    INTEGRAL_VALUE  reduce using rule 40 (statement -> expression END .)
    RBRACE          reduce using rule 40 (statement -> expression END .)


state 97

    (71) expression -> expression OR . comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    comparison_layer               shift and go to state 120
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 98

    (72) expression -> expression AND . comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    comparison_layer               shift and go to state 121
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 99

    (59) return_statement -> RETURN expression . END
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    END             shift and go to state 122
    OR              shift and go to state 97
    AND             shift and go to state 98


state 100

    (55) if_statement -> IF LPAREN . expression RPAREN scope else_statement
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    expression                     shift and go to state 123
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 101

    (53) for_statement -> FOR LPAREN . new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (24) new_scope -> .
    ID              reduce using rule 24 (new_scope -> .)
    DECLARE         reduce using rule 24 (new_scope -> .)
    LPAREN          reduce using rule 24 (new_scope -> .)
    STRING_VALUE    reduce using rule 24 (new_scope -> .)
    CHAR_VALUE      reduce using rule 24 (new_scope -> .)
    BOOL_VALUE      reduce using rule 24 (new_scope -> .)
    FLOAT_VALUE     reduce using rule 24 (new_scope -> .)
    INTEGRAL_VALUE  reduce using rule 24 (new_scope -> .)
    END             reduce using rule 24 (new_scope -> .)

    new_scope                      shift and go to state 124

state 102

    (54) while_statement -> WHILE LPAREN . expression RPAREN scope
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    expression                     shift and go to state 125
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 103

    (76) arithmetic_layer -> arithmetic_layer MINUS . term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    term                           shift and go to state 126
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 104

    (77) arithmetic_layer -> arithmetic_layer PLUS . term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    term                           shift and go to state 127
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 105

    (63) array_declaration_init -> DECLARE ID . LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> DECLARE ID . COLON type ASSIGN expression
    (61) array_declaration -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (60) scalar_declaration -> DECLARE ID . COLON type
    LSBRACKET       shift and go to state 128
    COLON           shift and go to state 129


state 106

    (74) comparison_layer -> comparison_layer COMPARATOR . arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    arithmetic_layer               shift and go to state 130
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 107

    (79) term -> term DIVISION . factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    factor                         shift and go to state 131
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 108

    (80) term -> term MULTIPLICATION . factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    factor                         shift and go to state 132
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 109

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON . type multi_formal_params
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 133

state 110

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 134


state 111

    (17) multi_formal_params -> COMMA ID COLON type multi_formal_params .
    RPAREN          reduce using rule 17 (multi_formal_params -> COMMA ID COLON type multi_formal_params .)


state 112

    (69) array_assignment -> ID LSBRACKET arithmetic_layer . RSBRACKET ASSIGN expression
    (82) factor -> ID LSBRACKET arithmetic_layer . RSBRACKET
    (76) arithmetic_layer -> arithmetic_layer . MINUS term
    (77) arithmetic_layer -> arithmetic_layer . PLUS term
    RSBRACKET       shift and go to state 135
    MINUS           shift and go to state 103
    PLUS            shift and go to state 104


state 113

    (68) scalar_assignment -> ID ASSIGN expression .
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    END             reduce using rule 68 (scalar_assignment -> ID ASSIGN expression .)
    RPAREN          reduce using rule 68 (scalar_assignment -> ID ASSIGN expression .)
    OR              shift and go to state 97
    AND             shift and go to state 98


state 114

    (18) function_call -> ID LPAREN actual_params . RPAREN
    RPAREN          shift and go to state 136


state 115

    (20) actual_params -> expression . multi_actual_params
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    (21) multi_actual_params -> .
    (22) multi_actual_params -> . COMMA expression multi_actual_params
    OR              shift and go to state 97
    AND             shift and go to state 98
    RPAREN          reduce using rule 21 (multi_actual_params -> .)
    COMMA           shift and go to state 138

    multi_actual_params            shift and go to state 137

state 116

    (84) factor -> LPAREN expression RPAREN .
    DIVISION        reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    MULTIPLICATION  reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    COMPARATOR      reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    RSBRACKET       reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 84 (factor -> LPAREN expression RPAREN .)


state 117

    (82) factor -> ID LSBRACKET . arithmetic_layer RSBRACKET
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    arithmetic_layer               shift and go to state 139
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 118

    (23) scope -> LBRACE new_scope statements . pop_scope RBRACE
    (25) pop_scope -> .
    RBRACE          reduce using rule 25 (pop_scope -> .)

    pop_scope                      shift and go to state 140

state 119

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .
    USE             reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)
    INCLUDE         reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)
    ID              reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)
    $end            reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)


state 120

    (71) expression -> expression OR comparison_layer .
    (74) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 71 (expression -> expression OR comparison_layer .)
    OR              reduce using rule 71 (expression -> expression OR comparison_layer .)
    AND             reduce using rule 71 (expression -> expression OR comparison_layer .)
    RPAREN          reduce using rule 71 (expression -> expression OR comparison_layer .)
    COMMA           reduce using rule 71 (expression -> expression OR comparison_layer .)
    COMPARATOR      shift and go to state 106


state 121

    (72) expression -> expression AND comparison_layer .
    (74) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 72 (expression -> expression AND comparison_layer .)
    OR              reduce using rule 72 (expression -> expression AND comparison_layer .)
    AND             reduce using rule 72 (expression -> expression AND comparison_layer .)
    RPAREN          reduce using rule 72 (expression -> expression AND comparison_layer .)
    COMMA           reduce using rule 72 (expression -> expression AND comparison_layer .)
    COMPARATOR      shift and go to state 106


state 122

    (59) return_statement -> RETURN expression END .
    END             reduce using rule 59 (return_statement -> RETURN expression END .)
    RETURN          reduce using rule 59 (return_statement -> RETURN expression END .)
    IF              reduce using rule 59 (return_statement -> RETURN expression END .)
    FOR             reduce using rule 59 (return_statement -> RETURN expression END .)
    WHILE           reduce using rule 59 (return_statement -> RETURN expression END .)
    LBRACE          reduce using rule 59 (return_statement -> RETURN expression END .)
    ID              reduce using rule 59 (return_statement -> RETURN expression END .)
    DECLARE         reduce using rule 59 (return_statement -> RETURN expression END .)
    LPAREN          reduce using rule 59 (return_statement -> RETURN expression END .)
    STRING_VALUE    reduce using rule 59 (return_statement -> RETURN expression END .)
    CHAR_VALUE      reduce using rule 59 (return_statement -> RETURN expression END .)
    BOOL_VALUE      reduce using rule 59 (return_statement -> RETURN expression END .)
    FLOAT_VALUE     reduce using rule 59 (return_statement -> RETURN expression END .)
    INTEGRAL_VALUE  reduce using rule 59 (return_statement -> RETURN expression END .)
    RBRACE          reduce using rule 59 (return_statement -> RETURN expression END .)


state 123

    (55) if_statement -> IF LPAREN expression . RPAREN scope else_statement
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 141
    OR              shift and go to state 97
    AND             shift and go to state 98


state 124

    (53) for_statement -> FOR LPAREN new_scope . for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (41) for_init -> .
    (42) for_init -> . expression
    (43) for_init -> . array_assignment
    (44) for_init -> . array_declaration_init
    (45) for_init -> . scalar_assignment
    (46) for_init -> . scalar_declaration_init
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (69) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (63) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (68) scalar_assignment -> . ID ASSIGN expression
    (62) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    END             reduce using rule 41 (for_init -> .)
    ID              shift and go to state 44
    DECLARE         shift and go to state 148
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    for_init                       shift and go to state 142
    expression                     shift and go to state 143
    array_assignment               shift and go to state 144
    array_declaration_init         shift and go to state 145
    scalar_assignment              shift and go to state 146
    scalar_declaration_init        shift and go to state 147
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 125

    (54) while_statement -> WHILE LPAREN expression . RPAREN scope
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 149
    OR              shift and go to state 97
    AND             shift and go to state 98


state 126

    (76) arithmetic_layer -> arithmetic_layer MINUS term .
    (79) term -> term . DIVISION factor
    (80) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    PLUS            reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    COMPARATOR      reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    END             reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    OR              reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    AND             reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    RPAREN          reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    RSBRACKET       reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    COMMA           reduce using rule 76 (arithmetic_layer -> arithmetic_layer MINUS term .)
    DIVISION        shift and go to state 107
    MULTIPLICATION  shift and go to state 108


state 127

    (77) arithmetic_layer -> arithmetic_layer PLUS term .
    (79) term -> term . DIVISION factor
    (80) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    PLUS            reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    COMPARATOR      reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    END             reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    OR              reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    AND             reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    RPAREN          reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    RSBRACKET       reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    COMMA           reduce using rule 77 (arithmetic_layer -> arithmetic_layer PLUS term .)
    DIVISION        shift and go to state 107
    MULTIPLICATION  shift and go to state 108


state 128

    (63) array_declaration_init -> DECLARE ID LSBRACKET . RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (61) array_declaration -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type
    RSBRACKET       shift and go to state 150
    INTEGRAL_VALUE  shift and go to state 151


state 129

    (62) scalar_declaration_init -> DECLARE ID COLON . type ASSIGN expression
    (60) scalar_declaration -> DECLARE ID COLON . type
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 152

state 130

    (74) comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .
    (76) arithmetic_layer -> arithmetic_layer . MINUS term
    (77) arithmetic_layer -> arithmetic_layer . PLUS term
    COMPARATOR      reduce using rule 74 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    END             reduce using rule 74 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    OR              reduce using rule 74 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    AND             reduce using rule 74 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    RPAREN          reduce using rule 74 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    COMMA           reduce using rule 74 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    MINUS           shift and go to state 103
    PLUS            shift and go to state 104


state 131

    (79) term -> term DIVISION factor .
    DIVISION        reduce using rule 79 (term -> term DIVISION factor .)
    MULTIPLICATION  reduce using rule 79 (term -> term DIVISION factor .)
    MINUS           reduce using rule 79 (term -> term DIVISION factor .)
    PLUS            reduce using rule 79 (term -> term DIVISION factor .)
    COMPARATOR      reduce using rule 79 (term -> term DIVISION factor .)
    END             reduce using rule 79 (term -> term DIVISION factor .)
    OR              reduce using rule 79 (term -> term DIVISION factor .)
    AND             reduce using rule 79 (term -> term DIVISION factor .)
    RPAREN          reduce using rule 79 (term -> term DIVISION factor .)
    RSBRACKET       reduce using rule 79 (term -> term DIVISION factor .)
    COMMA           reduce using rule 79 (term -> term DIVISION factor .)


state 132

    (80) term -> term MULTIPLICATION factor .
    DIVISION        reduce using rule 80 (term -> term MULTIPLICATION factor .)
    MULTIPLICATION  reduce using rule 80 (term -> term MULTIPLICATION factor .)
    MINUS           reduce using rule 80 (term -> term MULTIPLICATION factor .)
    PLUS            reduce using rule 80 (term -> term MULTIPLICATION factor .)
    COMPARATOR      reduce using rule 80 (term -> term MULTIPLICATION factor .)
    END             reduce using rule 80 (term -> term MULTIPLICATION factor .)
    OR              reduce using rule 80 (term -> term MULTIPLICATION factor .)
    AND             reduce using rule 80 (term -> term MULTIPLICATION factor .)
    RPAREN          reduce using rule 80 (term -> term MULTIPLICATION factor .)
    RSBRACKET       reduce using rule 80 (term -> term MULTIPLICATION factor .)
    COMMA           reduce using rule 80 (term -> term MULTIPLICATION factor .)


state 133

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 34

    multi_formal_params            shift and go to state 153

state 134

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type multi_formal_params
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 154

state 135

    (69) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET . ASSIGN expression
    (82) factor -> ID LSBRACKET arithmetic_layer RSBRACKET .
    ASSIGN          shift and go to state 155
    DIVISION        reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MULTIPLICATION  reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MINUS           reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    PLUS            reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMPARATOR      reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    END             reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    OR              reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    AND             reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RPAREN          reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)


state 136

    (18) function_call -> ID LPAREN actual_params RPAREN .
    DIVISION        reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    MULTIPLICATION  reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    MINUS           reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    PLUS            reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    COMPARATOR      reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    END             reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    OR              reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    AND             reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    RPAREN          reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    RSBRACKET       reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    COMMA           reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)


state 137

    (20) actual_params -> expression multi_actual_params .
    RPAREN          reduce using rule 20 (actual_params -> expression multi_actual_params .)


state 138

    (22) multi_actual_params -> COMMA . expression multi_actual_params
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    expression                     shift and go to state 156
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 139

    (82) factor -> ID LSBRACKET arithmetic_layer . RSBRACKET
    (76) arithmetic_layer -> arithmetic_layer . MINUS term
    (77) arithmetic_layer -> arithmetic_layer . PLUS term
    RSBRACKET       shift and go to state 157
    MINUS           shift and go to state 103
    PLUS            shift and go to state 104


state 140

    (23) scope -> LBRACE new_scope statements pop_scope . RBRACE
    RBRACE          shift and go to state 158


state 141

    (55) if_statement -> IF LPAREN expression RPAREN . scope else_statement
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 46

    scope                          shift and go to state 159

state 142

    (53) for_statement -> FOR LPAREN new_scope for_init . END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    END             shift and go to state 160


state 143

    (42) for_init -> expression .
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    END             reduce using rule 42 (for_init -> expression .)
    OR              shift and go to state 97
    AND             shift and go to state 98


state 144

    (43) for_init -> array_assignment .
    END             reduce using rule 43 (for_init -> array_assignment .)


state 145

    (44) for_init -> array_declaration_init .
    END             reduce using rule 44 (for_init -> array_declaration_init .)


state 146

    (45) for_init -> scalar_assignment .
    END             reduce using rule 45 (for_init -> scalar_assignment .)


state 147

    (46) for_init -> scalar_declaration_init .
    END             reduce using rule 46 (for_init -> scalar_declaration_init .)


state 148

    (63) array_declaration_init -> DECLARE . ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> DECLARE . ID COLON type ASSIGN expression
    ID              shift and go to state 161


state 149

    (54) while_statement -> WHILE LPAREN expression RPAREN . scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 46

    scope                          shift and go to state 162

state 150

    (63) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET . COLON type ASSIGN array_init
    COLON           shift and go to state 163


state 151

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type ASSIGN array_init
    (61) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type
    RSBRACKET       shift and go to state 164


state 152

    (62) scalar_declaration_init -> DECLARE ID COLON type . ASSIGN expression
    (60) scalar_declaration -> DECLARE ID COLON type .
    ASSIGN          shift and go to state 165
    END             reduce using rule 60 (scalar_declaration -> DECLARE ID COLON type .)


state 153

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 15 (multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params .)


state 154

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 34

    multi_formal_params            shift and go to state 166

state 155

    (69) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN . expression
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    arithmetic_layer               shift and go to state 66
    expression                     shift and go to state 167
    comparison_layer               shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 156

    (22) multi_actual_params -> COMMA expression . multi_actual_params
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    (21) multi_actual_params -> .
    (22) multi_actual_params -> . COMMA expression multi_actual_params
    OR              shift and go to state 97
    AND             shift and go to state 98
    RPAREN          reduce using rule 21 (multi_actual_params -> .)
    COMMA           shift and go to state 138

    multi_actual_params            shift and go to state 168

state 157

    (82) factor -> ID LSBRACKET arithmetic_layer RSBRACKET .
    DIVISION        reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MULTIPLICATION  reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MINUS           reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    PLUS            reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMPARATOR      reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RPAREN          reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    OR              reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    AND             reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    END             reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RSBRACKET       reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMMA           reduce using rule 82 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)


state 158

    (23) scope -> LBRACE new_scope statements pop_scope RBRACE .
    END             reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    RETURN          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    IF              reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    FOR             reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    WHILE           reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    LBRACE          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    ID              reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    DECLARE         reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    LPAREN          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    STRING_VALUE    reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    CHAR_VALUE      reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    BOOL_VALUE      reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    FLOAT_VALUE     reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    INTEGRAL_VALUE  reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    RBRACE          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    ELSE            reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)


state 159

    (55) if_statement -> IF LPAREN expression RPAREN scope . else_statement
    (56) else_statement -> .
    (57) else_statement -> . ELSE if_statement
    (58) else_statement -> . ELSE scope
    END             reduce using rule 56 (else_statement -> .)
    RETURN          reduce using rule 56 (else_statement -> .)
    IF              reduce using rule 56 (else_statement -> .)
    FOR             reduce using rule 56 (else_statement -> .)
    WHILE           reduce using rule 56 (else_statement -> .)
    LBRACE          reduce using rule 56 (else_statement -> .)
    ID              reduce using rule 56 (else_statement -> .)
    DECLARE         reduce using rule 56 (else_statement -> .)
    LPAREN          reduce using rule 56 (else_statement -> .)
    STRING_VALUE    reduce using rule 56 (else_statement -> .)
    CHAR_VALUE      reduce using rule 56 (else_statement -> .)
    BOOL_VALUE      reduce using rule 56 (else_statement -> .)
    FLOAT_VALUE     reduce using rule 56 (else_statement -> .)
    INTEGRAL_VALUE  reduce using rule 56 (else_statement -> .)
    RBRACE          reduce using rule 56 (else_statement -> .)
    ELSE            shift and go to state 170

    else_statement                 shift and go to state 169

state 160

    (53) for_statement -> FOR LPAREN new_scope for_init END . for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (47) for_condition -> .
    (48) for_condition -> . expression
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    END             reduce using rule 47 (for_condition -> .)
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    for_condition                  shift and go to state 171
    expression                     shift and go to state 172
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 161

    (63) array_declaration_init -> DECLARE ID . LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> DECLARE ID . COLON type ASSIGN expression
    LSBRACKET       shift and go to state 173
    COLON           shift and go to state 174


state 162

    (54) while_statement -> WHILE LPAREN expression RPAREN scope .
    END             reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    RETURN          reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    IF              reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    FOR             reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    WHILE           reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    LBRACE          reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    ID              reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    DECLARE         reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    LPAREN          reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    STRING_VALUE    reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    CHAR_VALUE      reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    BOOL_VALUE      reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    FLOAT_VALUE     reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    INTEGRAL_VALUE  reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    RBRACE          reduce using rule 54 (while_statement -> WHILE LPAREN expression RPAREN scope .)


state 163

    (63) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON . type ASSIGN array_init
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 175

state 164

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type ASSIGN array_init
    (61) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type
    COLON           shift and go to state 176


state 165

    (62) scalar_declaration_init -> DECLARE ID COLON type ASSIGN . expression
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 86
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    expression                     shift and go to state 177
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 166

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 16 (multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .)


state 167

    (69) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    END             reduce using rule 69 (array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .)
    RPAREN          reduce using rule 69 (array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .)
    OR              shift and go to state 97
    AND             shift and go to state 98


state 168

    (22) multi_actual_params -> COMMA expression multi_actual_params .
    RPAREN          reduce using rule 22 (multi_actual_params -> COMMA expression multi_actual_params .)


state 169

    (55) if_statement -> IF LPAREN expression RPAREN scope else_statement .
    END             reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    RETURN          reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    IF              reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    FOR             reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    WHILE           reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    LBRACE          reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    ID              reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    DECLARE         reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    LPAREN          reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    STRING_VALUE    reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    CHAR_VALUE      reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    BOOL_VALUE      reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    FLOAT_VALUE     reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    INTEGRAL_VALUE  reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    RBRACE          reduce using rule 55 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)


state 170

    (57) else_statement -> ELSE . if_statement
    (58) else_statement -> ELSE . scope
    (55) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    IF              shift and go to state 63
    LBRACE          shift and go to state 46

    if_statement                   shift and go to state 178
    scope                          shift and go to state 179

state 171

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition . END for_increment RPAREN LBRACE statements pop_scope RBRACE
    END             shift and go to state 180


state 172

    (48) for_condition -> expression .
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    END             reduce using rule 48 (for_condition -> expression .)
    OR              shift and go to state 97
    AND             shift and go to state 98


state 173

    (63) array_declaration_init -> DECLARE ID LSBRACKET . RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    RSBRACKET       shift and go to state 150
    INTEGRAL_VALUE  shift and go to state 181


state 174

    (62) scalar_declaration_init -> DECLARE ID COLON . type ASSIGN expression
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 182

state 175

    (63) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type . ASSIGN array_init
    ASSIGN          shift and go to state 183


state 176

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type ASSIGN array_init
    (61) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 184

state 177

    (62) scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression .
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    END             reduce using rule 62 (scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression .)
    OR              shift and go to state 97
    AND             shift and go to state 98


state 178

    (57) else_statement -> ELSE if_statement .
    END             reduce using rule 57 (else_statement -> ELSE if_statement .)
    RETURN          reduce using rule 57 (else_statement -> ELSE if_statement .)
    IF              reduce using rule 57 (else_statement -> ELSE if_statement .)
    FOR             reduce using rule 57 (else_statement -> ELSE if_statement .)
    WHILE           reduce using rule 57 (else_statement -> ELSE if_statement .)
    LBRACE          reduce using rule 57 (else_statement -> ELSE if_statement .)
    ID              reduce using rule 57 (else_statement -> ELSE if_statement .)
    DECLARE         reduce using rule 57 (else_statement -> ELSE if_statement .)
    LPAREN          reduce using rule 57 (else_statement -> ELSE if_statement .)
    STRING_VALUE    reduce using rule 57 (else_statement -> ELSE if_statement .)
    CHAR_VALUE      reduce using rule 57 (else_statement -> ELSE if_statement .)
    BOOL_VALUE      reduce using rule 57 (else_statement -> ELSE if_statement .)
    FLOAT_VALUE     reduce using rule 57 (else_statement -> ELSE if_statement .)
    INTEGRAL_VALUE  reduce using rule 57 (else_statement -> ELSE if_statement .)
    RBRACE          reduce using rule 57 (else_statement -> ELSE if_statement .)


state 179

    (58) else_statement -> ELSE scope .
    END             reduce using rule 58 (else_statement -> ELSE scope .)
    RETURN          reduce using rule 58 (else_statement -> ELSE scope .)
    IF              reduce using rule 58 (else_statement -> ELSE scope .)
    FOR             reduce using rule 58 (else_statement -> ELSE scope .)
    WHILE           reduce using rule 58 (else_statement -> ELSE scope .)
    LBRACE          reduce using rule 58 (else_statement -> ELSE scope .)
    ID              reduce using rule 58 (else_statement -> ELSE scope .)
    DECLARE         reduce using rule 58 (else_statement -> ELSE scope .)
    LPAREN          reduce using rule 58 (else_statement -> ELSE scope .)
    STRING_VALUE    reduce using rule 58 (else_statement -> ELSE scope .)
    CHAR_VALUE      reduce using rule 58 (else_statement -> ELSE scope .)
    BOOL_VALUE      reduce using rule 58 (else_statement -> ELSE scope .)
    FLOAT_VALUE     reduce using rule 58 (else_statement -> ELSE scope .)
    INTEGRAL_VALUE  reduce using rule 58 (else_statement -> ELSE scope .)
    RBRACE          reduce using rule 58 (else_statement -> ELSE scope .)


state 180

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition END . for_increment RPAREN LBRACE statements pop_scope RBRACE
    (49) for_increment -> .
    (50) for_increment -> . expression
    (51) for_increment -> . array_assignment
    (52) for_increment -> . scalar_assignment
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (69) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (68) scalar_assignment -> . ID ASSIGN expression
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RPAREN          reduce using rule 49 (for_increment -> .)
    ID              shift and go to state 44
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    for_increment                  shift and go to state 185
    expression                     shift and go to state 186
    array_assignment               shift and go to state 187
    scalar_assignment              shift and go to state 188
    comparison_layer               shift and go to state 69
    arithmetic_layer               shift and go to state 66
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 181

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type ASSIGN array_init
    RSBRACKET       shift and go to state 189


state 182

    (62) scalar_declaration_init -> DECLARE ID COLON type . ASSIGN expression
    ASSIGN          shift and go to state 165


state 183

    (63) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN . array_init
    (65) array_init -> . LBRACE value multi_array_init RBRACE
    LBRACE          shift and go to state 191

    array_init                     shift and go to state 190

state 184

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . ASSIGN array_init
    (61) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type .
    ASSIGN          shift and go to state 192
    END             reduce using rule 61 (array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type .)


state 185

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment . RPAREN LBRACE statements pop_scope RBRACE
    RPAREN          shift and go to state 193


state 186

    (50) for_increment -> expression .
    (71) expression -> expression . OR comparison_layer
    (72) expression -> expression . AND comparison_layer
    RPAREN          reduce using rule 50 (for_increment -> expression .)
    OR              shift and go to state 97
    AND             shift and go to state 98


state 187

    (51) for_increment -> array_assignment .
    RPAREN          reduce using rule 51 (for_increment -> array_assignment .)


state 188

    (52) for_increment -> scalar_assignment .
    RPAREN          reduce using rule 52 (for_increment -> scalar_assignment .)


state 189

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type ASSIGN array_init
    COLON           shift and go to state 194


state 190

    (63) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init .
    END             reduce using rule 63 (array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init .)


state 191

    (65) array_init -> LBRACE . value multi_array_init RBRACE
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    value                          shift and go to state 195

state 192

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN . array_init
    (65) array_init -> . LBRACE value multi_array_init RBRACE
    LBRACE          shift and go to state 191

    array_init                     shift and go to state 196

state 193

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN . LBRACE statements pop_scope RBRACE
    LBRACE          shift and go to state 197


state 194

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type ASSIGN array_init
    (86) type -> . ABYSS_TYPE
    (87) type -> . BOOL_TYPE
    (88) type -> . STRING_TYPE
    (89) type -> . CHAR_TYPE
    (90) type -> . FLOAT_TYPE
    (91) type -> . UNSIGNED_TYPE
    (92) type -> . SIGNED_TYPE
    ABYSS_TYPE      shift and go to state 23
    BOOL_TYPE       shift and go to state 24
    STRING_TYPE     shift and go to state 25
    CHAR_TYPE       shift and go to state 26
    FLOAT_TYPE      shift and go to state 27
    UNSIGNED_TYPE   shift and go to state 28
    SIGNED_TYPE     shift and go to state 29

    type                           shift and go to state 198

state 195

    (65) array_init -> LBRACE value . multi_array_init RBRACE
    (66) multi_array_init -> .
    (67) multi_array_init -> . COMMA value multi_array_init
    RBRACE          reduce using rule 66 (multi_array_init -> .)
    COMMA           shift and go to state 200

    multi_array_init               shift and go to state 199

state 196

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init .
    END             reduce using rule 64 (array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init .)


state 197

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE . statements pop_scope RBRACE
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . return_statement
    (30) statement -> . if_statement
    (31) statement -> . for_statement
    (32) statement -> . while_statement
    (33) statement -> . scope
    (34) statement -> . array_assignment END
    (35) statement -> . scalar_assignment END
    (36) statement -> . array_declaration_init END
    (37) statement -> . scalar_declaration_init END
    (38) statement -> . array_declaration END
    (39) statement -> . scalar_declaration END
    (40) statement -> . expression END
    (59) return_statement -> . RETURN expression END
    (55) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (53) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (54) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (69) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (68) scalar_assignment -> . ID ASSIGN expression
    (63) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (64) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (61) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (60) scalar_declaration -> . DECLARE ID COLON type
    (70) expression -> . comparison_layer
    (71) expression -> . expression OR comparison_layer
    (72) expression -> . expression AND comparison_layer
    (73) comparison_layer -> . arithmetic_layer
    (74) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (75) arithmetic_layer -> . term
    (76) arithmetic_layer -> . arithmetic_layer MINUS term
    (77) arithmetic_layer -> . arithmetic_layer PLUS term
    (78) term -> . factor
    (79) term -> . term DIVISION factor
    (80) term -> . term MULTIPLICATION factor
    (81) factor -> . ID
    (82) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (83) factor -> . value
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . function_call
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 49
    RETURN          shift and go to state 62
    IF              shift and go to state 63
    FOR             shift and go to state 64
    WHILE           shift and go to state 65
    LBRACE          shift and go to state 46
    ID              shift and go to state 44
    DECLARE         shift and go to state 67
    LPAREN          shift and go to state 45
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    statements                     shift and go to state 201
    statement                      shift and go to state 48
    return_statement               shift and go to state 50
    if_statement                   shift and go to state 51
    for_statement                  shift and go to state 52
    while_statement                shift and go to state 53
    scope                          shift and go to state 54
    array_assignment               shift and go to state 55
    scalar_assignment              shift and go to state 56
    array_declaration_init         shift and go to state 57
    scalar_declaration_init        shift and go to state 58
    array_declaration              shift and go to state 59
    scalar_declaration             shift and go to state 60
    expression                     shift and go to state 61
    arithmetic_layer               shift and go to state 66
    comparison_layer               shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    value                          shift and go to state 72
    function_call                  shift and go to state 73

state 198

    (64) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . ASSIGN array_init
    ASSIGN          shift and go to state 192


state 199

    (65) array_init -> LBRACE value multi_array_init . RBRACE
    RBRACE          shift and go to state 202


state 200

    (67) multi_array_init -> COMMA . value multi_array_init
    (93) value -> . STRING_VALUE
    (94) value -> . CHAR_VALUE
    (95) value -> . BOOL_VALUE
    (96) value -> . FLOAT_VALUE
    (97) value -> . INTEGRAL_VALUE
    STRING_VALUE    shift and go to state 74
    CHAR_VALUE      shift and go to state 75
    BOOL_VALUE      shift and go to state 76
    FLOAT_VALUE     shift and go to state 77
    INTEGRAL_VALUE  shift and go to state 68

    value                          shift and go to state 203

state 201

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements . pop_scope RBRACE
    (25) pop_scope -> .
    RBRACE          reduce using rule 25 (pop_scope -> .)

    pop_scope                      shift and go to state 204

state 202

    (65) array_init -> LBRACE value multi_array_init RBRACE .
    END             reduce using rule 65 (array_init -> LBRACE value multi_array_init RBRACE .)


state 203

    (67) multi_array_init -> COMMA value . multi_array_init
    (66) multi_array_init -> .
    (67) multi_array_init -> . COMMA value multi_array_init
    RBRACE          reduce using rule 66 (multi_array_init -> .)
    COMMA           shift and go to state 200

    multi_array_init               shift and go to state 205

state 204

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope . RBRACE
    RBRACE          shift and go to state 206


state 205

    (67) multi_array_init -> COMMA value multi_array_init .
    RBRACE          reduce using rule 67 (multi_array_init -> COMMA value multi_array_init .)


state 206

    (53) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .
    END             reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    RETURN          reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    IF              reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    FOR             reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    WHILE           reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    LBRACE          reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    ID              reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    DECLARE         reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    LPAREN          reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    STRING_VALUE    reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    CHAR_VALUE      reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    BOOL_VALUE      reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    FLOAT_VALUE     reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    INTEGRAL_VALUE  reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    RBRACE          reduce using rule 53 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
