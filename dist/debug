Grammar:

Rule 0     S' -> program
Rule 1     program -> globals
Rule 2     globals -> <empty>
Rule 3     globals -> globall globals
Rule 4     globall -> include
Rule 5     globall -> function
Rule 6     include -> USE STRING_VALUE
Rule 7     include -> INCLUDE SYSTEM_VALUE
Rule 8     include -> INCLUDE STRING_VALUE
Rule 9     function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
Rule 10    formal_params -> <empty>
Rule 11    formal_params -> ID LSBRACKET RSBRACKET COLON type multi_formal_params
Rule 12    formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
Rule 13    formal_params -> ID COLON type multi_formal_params
Rule 14    multi_formal_params -> <empty>
Rule 15    multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
Rule 16    multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
Rule 17    multi_formal_params -> COMMA ID COLON type multi_formal_params
Rule 18    function_call -> ID LPAREN actual_params RPAREN
Rule 19    actual_params -> <empty>
Rule 20    actual_params -> expression multi_actual_params
Rule 21    multi_actual_params -> <empty>
Rule 22    multi_actual_params -> COMMA expression multi_actual_params
Rule 23    scope -> LBRACE new_scope statements pop_scope RBRACE
Rule 24    new_scope -> <empty>
Rule 25    pop_scope -> <empty>
Rule 26    statements -> <empty>
Rule 27    statements -> statement statements
Rule 28    statement -> END
Rule 29    statement -> insertion_statement END
Rule 30    statement -> return_statement
Rule 31    statement -> if_statement
Rule 32    statement -> for_statement
Rule 33    statement -> while_statement
Rule 34    statement -> scope
Rule 35    statement -> array_assignment END
Rule 36    statement -> scalar_assignment END
Rule 37    statement -> array_declaration_init END
Rule 38    statement -> scalar_declaration_init END
Rule 39    statement -> array_declaration END
Rule 40    statement -> scalar_declaration END
Rule 41    statement -> expression END
Rule 42    for_init -> <empty>
Rule 43    for_init -> expression
Rule 44    for_init -> array_assignment
Rule 45    for_init -> array_declaration_init
Rule 46    for_init -> scalar_assignment
Rule 47    for_init -> scalar_declaration_init
Rule 48    for_condition -> <empty>
Rule 49    for_condition -> expression
Rule 50    for_increment -> <empty>
Rule 51    for_increment -> expression
Rule 52    for_increment -> array_assignment
Rule 53    for_increment -> scalar_assignment
Rule 54    for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
Rule 55    while_statement -> WHILE LPAREN expression RPAREN scope
Rule 56    if_statement -> IF LPAREN expression RPAREN scope else_statement
Rule 57    else_statement -> <empty>
Rule 58    else_statement -> ELSE if_statement
Rule 59    else_statement -> ELSE scope
Rule 60    return_statement -> RETURN expression END
Rule 61    scalar_declaration -> DECLARE ID COLON type
Rule 62    array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
Rule 63    scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression
Rule 64    array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
Rule 65    array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
Rule 66    array_init -> LBRACE value multi_array_init RBRACE
Rule 67    array_init -> STRING_VALUE
Rule 68    multi_array_init -> <empty>
Rule 69    multi_array_init -> COMMA value multi_array_init
Rule 70    scalar_assignment -> ID ASSIGN expression
Rule 71    array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
Rule 72    insertion_statement -> expression INSERTION expression multi_insertion
Rule 73    multi_insertion -> <empty>
Rule 74    multi_insertion -> INSERTION expression multi_insertion
Rule 75    expression -> comparison_layer
Rule 76    expression -> expression OR comparison_layer
Rule 77    expression -> expression AND comparison_layer
Rule 78    comparison_layer -> arithmetic_layer
Rule 79    comparison_layer -> comparison_layer COMPARATOR arithmetic_layer
Rule 80    arithmetic_layer -> term
Rule 81    arithmetic_layer -> arithmetic_layer MINUS term
Rule 82    arithmetic_layer -> arithmetic_layer PLUS term
Rule 83    term -> factor
Rule 84    term -> term DIVISION factor
Rule 85    term -> term MULTIPLICATION factor
Rule 86    factor -> ID
Rule 87    factor -> ID LSBRACKET arithmetic_layer RSBRACKET
Rule 88    factor -> value
Rule 89    factor -> LPAREN expression RPAREN
Rule 90    factor -> function_call
Rule 91    type -> ID
Rule 92    type -> ABYSS_TYPE
Rule 93    type -> BOOL_TYPE
Rule 94    type -> STRING_TYPE
Rule 95    type -> CHAR_TYPE
Rule 96    type -> FLOAT_TYPE
Rule 97    type -> UNSIGNED_TYPE
Rule 98    type -> SIGNED_TYPE
Rule 99    value -> STRING_VALUE
Rule 100   value -> CHAR_VALUE
Rule 101   value -> BOOL_VALUE
Rule 102   value -> FLOAT_VALUE
Rule 103   value -> INTEGRAL_VALUE

Unused terminals:

    EXTRACTION

Terminals, with rules where they appear:

ABYSS_TYPE           : 92
AND                  : 77
ASSIGN               : 63 64 65 70 71
BOOL_TYPE            : 93
BOOL_VALUE           : 101
CHAR_TYPE            : 95
CHAR_VALUE           : 100
COLON                : 9 11 12 13 15 16 17 61 62 63 64 65
COMMA                : 15 16 17 22 69
COMPARATOR           : 79
DECLARE              : 61 62 63 64 65
DIVISION             : 84
ELSE                 : 58 59
END                  : 28 29 35 36 37 38 39 40 41 54 54 60
EXTRACTION           : 
FLOAT_TYPE           : 96
FLOAT_VALUE          : 102
FOR                  : 54
ID                   : 9 11 12 13 15 16 17 18 61 62 63 64 65 70 71 86 87 91
IF                   : 56
INCLUDE              : 7 8
INSERTION            : 72 74
INTEGRAL_VALUE       : 12 16 62 65 103
LBRACE               : 9 23 54 66
LPAREN               : 9 18 54 55 56 89
LSBRACKET            : 11 12 15 16 62 64 65 71 87
MINUS                : 81
MULTIPLICATION       : 85
OR                   : 76
PLUS                 : 82
RBRACE               : 9 23 54 66
RETURN               : 60
RPAREN               : 9 18 54 55 56 89
RSBRACKET            : 11 12 15 16 62 64 65 71 87
SIGNED_TYPE          : 98
STRING_TYPE          : 94
STRING_VALUE         : 6 8 67 99
SYSTEM_VALUE         : 7
UNSIGNED_TYPE        : 97
USE                  : 6
WHILE                : 55
error                : 

Nonterminals, with rules where they appear:

actual_params        : 18
arithmetic_layer     : 71 78 79 81 82 87
array_assignment     : 35 44 52
array_declaration    : 39
array_declaration_init : 37 45
array_init           : 64 65
comparison_layer     : 75 76 77 79
else_statement       : 56
expression           : 20 22 41 43 49 51 55 56 60 63 70 71 72 72 74 76 77 89
factor               : 83 84 85
for_condition        : 54
for_increment        : 54
for_init             : 54
for_statement        : 32
formal_params        : 9
function             : 5
function_call        : 90
globall              : 3
globals              : 1 3
if_statement         : 31 58
include              : 4
insertion_statement  : 29
multi_actual_params  : 20 22
multi_array_init     : 66 69
multi_formal_params  : 11 12 13 15 16 17
multi_insertion      : 72 74
new_scope            : 9 23 54
pop_scope            : 9 23 54
program              : 0
return_statement     : 30
scalar_assignment    : 36 46 53
scalar_declaration   : 40
scalar_declaration_init : 38 47
scope                : 34 55 56 59
statement            : 27
statements           : 9 23 27 54
term                 : 80 81 82 84 85
type                 : 9 11 12 13 15 16 17 61 62 63 64 65
value                : 66 69 88
while_statement      : 33


state 0

    (0) S' -> . program
    (1) program -> . globals
    (2) globals -> .
    (3) globals -> . globall globals
    (4) globall -> . include
    (5) globall -> . function
    (6) include -> . USE STRING_VALUE
    (7) include -> . INCLUDE SYSTEM_VALUE
    (8) include -> . INCLUDE STRING_VALUE
    (9) function -> . ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    $end            reduce using rule 2 (globals -> .)
    USE             shift and go to state 6
    INCLUDE         shift and go to state 7
    ID              shift and go to state 8

    program                        shift and go to state 1
    globals                        shift and go to state 2
    globall                        shift and go to state 3
    include                        shift and go to state 4
    function                       shift and go to state 5

state 1

    (0) S' -> program .


state 2

    (1) program -> globals .
    $end            reduce using rule 1 (program -> globals .)


state 3

    (3) globals -> globall . globals
    (2) globals -> .
    (3) globals -> . globall globals
    (4) globall -> . include
    (5) globall -> . function
    (6) include -> . USE STRING_VALUE
    (7) include -> . INCLUDE SYSTEM_VALUE
    (8) include -> . INCLUDE STRING_VALUE
    (9) function -> . ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    $end            reduce using rule 2 (globals -> .)
    USE             shift and go to state 6
    INCLUDE         shift and go to state 7
    ID              shift and go to state 8

    globall                        shift and go to state 3
    globals                        shift and go to state 9
    include                        shift and go to state 4
    function                       shift and go to state 5

state 4

    (4) globall -> include .
    USE             reduce using rule 4 (globall -> include .)
    INCLUDE         reduce using rule 4 (globall -> include .)
    ID              reduce using rule 4 (globall -> include .)
    $end            reduce using rule 4 (globall -> include .)


state 5

    (5) globall -> function .
    USE             reduce using rule 5 (globall -> function .)
    INCLUDE         reduce using rule 5 (globall -> function .)
    ID              reduce using rule 5 (globall -> function .)
    $end            reduce using rule 5 (globall -> function .)


state 6

    (6) include -> USE . STRING_VALUE
    STRING_VALUE    shift and go to state 10


state 7

    (7) include -> INCLUDE . SYSTEM_VALUE
    (8) include -> INCLUDE . STRING_VALUE
    SYSTEM_VALUE    shift and go to state 11
    STRING_VALUE    shift and go to state 12


state 8

    (9) function -> ID . LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    LPAREN          shift and go to state 13


state 9

    (3) globals -> globall globals .
    $end            reduce using rule 3 (globals -> globall globals .)


state 10

    (6) include -> USE STRING_VALUE .
    USE             reduce using rule 6 (include -> USE STRING_VALUE .)
    INCLUDE         reduce using rule 6 (include -> USE STRING_VALUE .)
    ID              reduce using rule 6 (include -> USE STRING_VALUE .)
    $end            reduce using rule 6 (include -> USE STRING_VALUE .)


state 11

    (7) include -> INCLUDE SYSTEM_VALUE .
    USE             reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)
    INCLUDE         reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)
    ID              reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)
    $end            reduce using rule 7 (include -> INCLUDE SYSTEM_VALUE .)


state 12

    (8) include -> INCLUDE STRING_VALUE .
    USE             reduce using rule 8 (include -> INCLUDE STRING_VALUE .)
    INCLUDE         reduce using rule 8 (include -> INCLUDE STRING_VALUE .)
    ID              reduce using rule 8 (include -> INCLUDE STRING_VALUE .)
    $end            reduce using rule 8 (include -> INCLUDE STRING_VALUE .)


state 13

    (9) function -> ID LPAREN . new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    (24) new_scope -> .
    ID              reduce using rule 24 (new_scope -> .)
    RPAREN          reduce using rule 24 (new_scope -> .)

    new_scope                      shift and go to state 14

state 14

    (9) function -> ID LPAREN new_scope . formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE
    (10) formal_params -> .
    (11) formal_params -> . ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (12) formal_params -> . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (13) formal_params -> . ID COLON type multi_formal_params
    RPAREN          reduce using rule 10 (formal_params -> .)
    ID              shift and go to state 15

    formal_params                  shift and go to state 16

state 15

    (11) formal_params -> ID . LSBRACKET RSBRACKET COLON type multi_formal_params
    (12) formal_params -> ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (13) formal_params -> ID . COLON type multi_formal_params
    LSBRACKET       shift and go to state 17
    COLON           shift and go to state 18


state 16

    (9) function -> ID LPAREN new_scope formal_params . RPAREN COLON type LBRACE statements pop_scope RBRACE
    RPAREN          shift and go to state 19


state 17

    (11) formal_params -> ID LSBRACKET . RSBRACKET COLON type multi_formal_params
    (12) formal_params -> ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 20
    INTEGRAL_VALUE  shift and go to state 21


state 18

    (13) formal_params -> ID COLON . type multi_formal_params
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 23

state 19

    (9) function -> ID LPAREN new_scope formal_params RPAREN . COLON type LBRACE statements pop_scope RBRACE
    COLON           shift and go to state 31


state 20

    (11) formal_params -> ID LSBRACKET RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 32


state 21

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 33


state 22

    (91) type -> ID .
    COMMA           reduce using rule 91 (type -> ID .)
    RPAREN          reduce using rule 91 (type -> ID .)
    LBRACE          reduce using rule 91 (type -> ID .)
    ASSIGN          reduce using rule 91 (type -> ID .)
    END             reduce using rule 91 (type -> ID .)


state 23

    (13) formal_params -> ID COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 35

    multi_formal_params            shift and go to state 34

state 24

    (92) type -> ABYSS_TYPE .
    COMMA           reduce using rule 92 (type -> ABYSS_TYPE .)
    RPAREN          reduce using rule 92 (type -> ABYSS_TYPE .)
    LBRACE          reduce using rule 92 (type -> ABYSS_TYPE .)
    ASSIGN          reduce using rule 92 (type -> ABYSS_TYPE .)
    END             reduce using rule 92 (type -> ABYSS_TYPE .)


state 25

    (93) type -> BOOL_TYPE .
    COMMA           reduce using rule 93 (type -> BOOL_TYPE .)
    RPAREN          reduce using rule 93 (type -> BOOL_TYPE .)
    LBRACE          reduce using rule 93 (type -> BOOL_TYPE .)
    ASSIGN          reduce using rule 93 (type -> BOOL_TYPE .)
    END             reduce using rule 93 (type -> BOOL_TYPE .)


state 26

    (94) type -> STRING_TYPE .
    COMMA           reduce using rule 94 (type -> STRING_TYPE .)
    RPAREN          reduce using rule 94 (type -> STRING_TYPE .)
    LBRACE          reduce using rule 94 (type -> STRING_TYPE .)
    ASSIGN          reduce using rule 94 (type -> STRING_TYPE .)
    END             reduce using rule 94 (type -> STRING_TYPE .)


state 27

    (95) type -> CHAR_TYPE .
    COMMA           reduce using rule 95 (type -> CHAR_TYPE .)
    RPAREN          reduce using rule 95 (type -> CHAR_TYPE .)
    LBRACE          reduce using rule 95 (type -> CHAR_TYPE .)
    ASSIGN          reduce using rule 95 (type -> CHAR_TYPE .)
    END             reduce using rule 95 (type -> CHAR_TYPE .)


state 28

    (96) type -> FLOAT_TYPE .
    COMMA           reduce using rule 96 (type -> FLOAT_TYPE .)
    RPAREN          reduce using rule 96 (type -> FLOAT_TYPE .)
    LBRACE          reduce using rule 96 (type -> FLOAT_TYPE .)
    ASSIGN          reduce using rule 96 (type -> FLOAT_TYPE .)
    END             reduce using rule 96 (type -> FLOAT_TYPE .)


state 29

    (97) type -> UNSIGNED_TYPE .
    COMMA           reduce using rule 97 (type -> UNSIGNED_TYPE .)
    RPAREN          reduce using rule 97 (type -> UNSIGNED_TYPE .)
    LBRACE          reduce using rule 97 (type -> UNSIGNED_TYPE .)
    ASSIGN          reduce using rule 97 (type -> UNSIGNED_TYPE .)
    END             reduce using rule 97 (type -> UNSIGNED_TYPE .)


state 30

    (98) type -> SIGNED_TYPE .
    COMMA           reduce using rule 98 (type -> SIGNED_TYPE .)
    RPAREN          reduce using rule 98 (type -> SIGNED_TYPE .)
    LBRACE          reduce using rule 98 (type -> SIGNED_TYPE .)
    ASSIGN          reduce using rule 98 (type -> SIGNED_TYPE .)
    END             reduce using rule 98 (type -> SIGNED_TYPE .)


state 31

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON . type LBRACE statements pop_scope RBRACE
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 36

state 32

    (11) formal_params -> ID LSBRACKET RSBRACKET COLON . type multi_formal_params
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 37

state 33

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 38


state 34

    (13) formal_params -> ID COLON type multi_formal_params .
    RPAREN          reduce using rule 13 (formal_params -> ID COLON type multi_formal_params .)


state 35

    (15) multi_formal_params -> COMMA . ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> COMMA . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> COMMA . ID COLON type multi_formal_params
    ID              shift and go to state 39


state 36

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type . LBRACE statements pop_scope RBRACE
    LBRACE          shift and go to state 40


state 37

    (11) formal_params -> ID LSBRACKET RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 35

    multi_formal_params            shift and go to state 41

state 38

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type multi_formal_params
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 42

state 39

    (15) multi_formal_params -> COMMA ID . LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> COMMA ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> COMMA ID . COLON type multi_formal_params
    LSBRACKET       shift and go to state 43
    COLON           shift and go to state 44


state 40

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE . statements pop_scope RBRACE
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . insertion_statement END
    (30) statement -> . return_statement
    (31) statement -> . if_statement
    (32) statement -> . for_statement
    (33) statement -> . while_statement
    (34) statement -> . scope
    (35) statement -> . array_assignment END
    (36) statement -> . scalar_assignment END
    (37) statement -> . array_declaration_init END
    (38) statement -> . scalar_declaration_init END
    (39) statement -> . array_declaration END
    (40) statement -> . scalar_declaration END
    (41) statement -> . expression END
    (72) insertion_statement -> . expression INSERTION expression multi_insertion
    (60) return_statement -> . RETURN expression END
    (56) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (54) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (55) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (71) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (70) scalar_assignment -> . ID ASSIGN expression
    (64) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (62) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (61) scalar_declaration -> . DECLARE ID COLON type
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 50
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 66
    WHILE           shift and go to state 67
    LBRACE          shift and go to state 47
    ID              shift and go to state 45
    DECLARE         shift and go to state 69
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    statements                     shift and go to state 48
    statement                      shift and go to state 49
    insertion_statement            shift and go to state 51
    return_statement               shift and go to state 52
    if_statement                   shift and go to state 53
    for_statement                  shift and go to state 54
    while_statement                shift and go to state 55
    scope                          shift and go to state 56
    array_assignment               shift and go to state 57
    scalar_assignment              shift and go to state 58
    array_declaration_init         shift and go to state 59
    scalar_declaration_init        shift and go to state 60
    array_declaration              shift and go to state 61
    scalar_declaration             shift and go to state 62
    expression                     shift and go to state 63
    arithmetic_layer               shift and go to state 68
    comparison_layer               shift and go to state 71
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 41

    (11) formal_params -> ID LSBRACKET RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 11 (formal_params -> ID LSBRACKET RSBRACKET COLON type multi_formal_params .)


state 42

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 35

    multi_formal_params            shift and go to state 80

state 43

    (15) multi_formal_params -> COMMA ID LSBRACKET . RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> COMMA ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 81
    INTEGRAL_VALUE  shift and go to state 82


state 44

    (17) multi_formal_params -> COMMA ID COLON . type multi_formal_params
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 83

state 45

    (71) array_assignment -> ID . LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (70) scalar_assignment -> ID . ASSIGN expression
    (86) factor -> ID .
    (87) factor -> ID . LSBRACKET arithmetic_layer RSBRACKET
    (18) function_call -> ID . LPAREN actual_params RPAREN
    LSBRACKET       shift and go to state 84
    ASSIGN          shift and go to state 85
    DIVISION        reduce using rule 86 (factor -> ID .)
    MULTIPLICATION  reduce using rule 86 (factor -> ID .)
    MINUS           reduce using rule 86 (factor -> ID .)
    PLUS            reduce using rule 86 (factor -> ID .)
    COMPARATOR      reduce using rule 86 (factor -> ID .)
    END             reduce using rule 86 (factor -> ID .)
    INSERTION       reduce using rule 86 (factor -> ID .)
    OR              reduce using rule 86 (factor -> ID .)
    AND             reduce using rule 86 (factor -> ID .)
    RPAREN          reduce using rule 86 (factor -> ID .)
    LPAREN          shift and go to state 86


state 46

    (89) factor -> LPAREN . expression RPAREN
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 87
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 47

    (23) scope -> LBRACE . new_scope statements pop_scope RBRACE
    (24) new_scope -> .
    END             reduce using rule 24 (new_scope -> .)
    RETURN          reduce using rule 24 (new_scope -> .)
    IF              reduce using rule 24 (new_scope -> .)
    FOR             reduce using rule 24 (new_scope -> .)
    WHILE           reduce using rule 24 (new_scope -> .)
    LBRACE          reduce using rule 24 (new_scope -> .)
    ID              reduce using rule 24 (new_scope -> .)
    DECLARE         reduce using rule 24 (new_scope -> .)
    LPAREN          reduce using rule 24 (new_scope -> .)
    STRING_VALUE    reduce using rule 24 (new_scope -> .)
    CHAR_VALUE      reduce using rule 24 (new_scope -> .)
    BOOL_VALUE      reduce using rule 24 (new_scope -> .)
    FLOAT_VALUE     reduce using rule 24 (new_scope -> .)
    INTEGRAL_VALUE  reduce using rule 24 (new_scope -> .)
    RBRACE          reduce using rule 24 (new_scope -> .)

    new_scope                      shift and go to state 89

state 48

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements . pop_scope RBRACE
    (25) pop_scope -> .
    RBRACE          reduce using rule 25 (pop_scope -> .)

    pop_scope                      shift and go to state 90

state 49

    (27) statements -> statement . statements
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . insertion_statement END
    (30) statement -> . return_statement
    (31) statement -> . if_statement
    (32) statement -> . for_statement
    (33) statement -> . while_statement
    (34) statement -> . scope
    (35) statement -> . array_assignment END
    (36) statement -> . scalar_assignment END
    (37) statement -> . array_declaration_init END
    (38) statement -> . scalar_declaration_init END
    (39) statement -> . array_declaration END
    (40) statement -> . scalar_declaration END
    (41) statement -> . expression END
    (72) insertion_statement -> . expression INSERTION expression multi_insertion
    (60) return_statement -> . RETURN expression END
    (56) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (54) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (55) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (71) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (70) scalar_assignment -> . ID ASSIGN expression
    (64) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (62) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (61) scalar_declaration -> . DECLARE ID COLON type
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 50
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 66
    WHILE           shift and go to state 67
    LBRACE          shift and go to state 47
    ID              shift and go to state 45
    DECLARE         shift and go to state 69
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    statement                      shift and go to state 49
    statements                     shift and go to state 91
    insertion_statement            shift and go to state 51
    return_statement               shift and go to state 52
    if_statement                   shift and go to state 53
    for_statement                  shift and go to state 54
    while_statement                shift and go to state 55
    scope                          shift and go to state 56
    array_assignment               shift and go to state 57
    scalar_assignment              shift and go to state 58
    array_declaration_init         shift and go to state 59
    scalar_declaration_init        shift and go to state 60
    array_declaration              shift and go to state 61
    scalar_declaration             shift and go to state 62
    expression                     shift and go to state 63
    arithmetic_layer               shift and go to state 68
    comparison_layer               shift and go to state 71
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 50

    (28) statement -> END .
    END             reduce using rule 28 (statement -> END .)
    RETURN          reduce using rule 28 (statement -> END .)
    IF              reduce using rule 28 (statement -> END .)
    FOR             reduce using rule 28 (statement -> END .)
    WHILE           reduce using rule 28 (statement -> END .)
    LBRACE          reduce using rule 28 (statement -> END .)
    ID              reduce using rule 28 (statement -> END .)
    DECLARE         reduce using rule 28 (statement -> END .)
    LPAREN          reduce using rule 28 (statement -> END .)
    STRING_VALUE    reduce using rule 28 (statement -> END .)
    CHAR_VALUE      reduce using rule 28 (statement -> END .)
    BOOL_VALUE      reduce using rule 28 (statement -> END .)
    FLOAT_VALUE     reduce using rule 28 (statement -> END .)
    INTEGRAL_VALUE  reduce using rule 28 (statement -> END .)
    RBRACE          reduce using rule 28 (statement -> END .)


state 51

    (29) statement -> insertion_statement . END
    END             shift and go to state 92


state 52

    (30) statement -> return_statement .
    END             reduce using rule 30 (statement -> return_statement .)
    RETURN          reduce using rule 30 (statement -> return_statement .)
    IF              reduce using rule 30 (statement -> return_statement .)
    FOR             reduce using rule 30 (statement -> return_statement .)
    WHILE           reduce using rule 30 (statement -> return_statement .)
    LBRACE          reduce using rule 30 (statement -> return_statement .)
    ID              reduce using rule 30 (statement -> return_statement .)
    DECLARE         reduce using rule 30 (statement -> return_statement .)
    LPAREN          reduce using rule 30 (statement -> return_statement .)
    STRING_VALUE    reduce using rule 30 (statement -> return_statement .)
    CHAR_VALUE      reduce using rule 30 (statement -> return_statement .)
    BOOL_VALUE      reduce using rule 30 (statement -> return_statement .)
    FLOAT_VALUE     reduce using rule 30 (statement -> return_statement .)
    INTEGRAL_VALUE  reduce using rule 30 (statement -> return_statement .)
    RBRACE          reduce using rule 30 (statement -> return_statement .)


state 53

    (31) statement -> if_statement .
    END             reduce using rule 31 (statement -> if_statement .)
    RETURN          reduce using rule 31 (statement -> if_statement .)
    IF              reduce using rule 31 (statement -> if_statement .)
    FOR             reduce using rule 31 (statement -> if_statement .)
    WHILE           reduce using rule 31 (statement -> if_statement .)
    LBRACE          reduce using rule 31 (statement -> if_statement .)
    ID              reduce using rule 31 (statement -> if_statement .)
    DECLARE         reduce using rule 31 (statement -> if_statement .)
    LPAREN          reduce using rule 31 (statement -> if_statement .)
    STRING_VALUE    reduce using rule 31 (statement -> if_statement .)
    CHAR_VALUE      reduce using rule 31 (statement -> if_statement .)
    BOOL_VALUE      reduce using rule 31 (statement -> if_statement .)
    FLOAT_VALUE     reduce using rule 31 (statement -> if_statement .)
    INTEGRAL_VALUE  reduce using rule 31 (statement -> if_statement .)
    RBRACE          reduce using rule 31 (statement -> if_statement .)


state 54

    (32) statement -> for_statement .
    END             reduce using rule 32 (statement -> for_statement .)
    RETURN          reduce using rule 32 (statement -> for_statement .)
    IF              reduce using rule 32 (statement -> for_statement .)
    FOR             reduce using rule 32 (statement -> for_statement .)
    WHILE           reduce using rule 32 (statement -> for_statement .)
    LBRACE          reduce using rule 32 (statement -> for_statement .)
    ID              reduce using rule 32 (statement -> for_statement .)
    DECLARE         reduce using rule 32 (statement -> for_statement .)
    LPAREN          reduce using rule 32 (statement -> for_statement .)
    STRING_VALUE    reduce using rule 32 (statement -> for_statement .)
    CHAR_VALUE      reduce using rule 32 (statement -> for_statement .)
    BOOL_VALUE      reduce using rule 32 (statement -> for_statement .)
    FLOAT_VALUE     reduce using rule 32 (statement -> for_statement .)
    INTEGRAL_VALUE  reduce using rule 32 (statement -> for_statement .)
    RBRACE          reduce using rule 32 (statement -> for_statement .)


state 55

    (33) statement -> while_statement .
    END             reduce using rule 33 (statement -> while_statement .)
    RETURN          reduce using rule 33 (statement -> while_statement .)
    IF              reduce using rule 33 (statement -> while_statement .)
    FOR             reduce using rule 33 (statement -> while_statement .)
    WHILE           reduce using rule 33 (statement -> while_statement .)
    LBRACE          reduce using rule 33 (statement -> while_statement .)
    ID              reduce using rule 33 (statement -> while_statement .)
    DECLARE         reduce using rule 33 (statement -> while_statement .)
    LPAREN          reduce using rule 33 (statement -> while_statement .)
    STRING_VALUE    reduce using rule 33 (statement -> while_statement .)
    CHAR_VALUE      reduce using rule 33 (statement -> while_statement .)
    BOOL_VALUE      reduce using rule 33 (statement -> while_statement .)
    FLOAT_VALUE     reduce using rule 33 (statement -> while_statement .)
    INTEGRAL_VALUE  reduce using rule 33 (statement -> while_statement .)
    RBRACE          reduce using rule 33 (statement -> while_statement .)


state 56

    (34) statement -> scope .
    END             reduce using rule 34 (statement -> scope .)
    RETURN          reduce using rule 34 (statement -> scope .)
    IF              reduce using rule 34 (statement -> scope .)
    FOR             reduce using rule 34 (statement -> scope .)
    WHILE           reduce using rule 34 (statement -> scope .)
    LBRACE          reduce using rule 34 (statement -> scope .)
    ID              reduce using rule 34 (statement -> scope .)
    DECLARE         reduce using rule 34 (statement -> scope .)
    LPAREN          reduce using rule 34 (statement -> scope .)
    STRING_VALUE    reduce using rule 34 (statement -> scope .)
    CHAR_VALUE      reduce using rule 34 (statement -> scope .)
    BOOL_VALUE      reduce using rule 34 (statement -> scope .)
    FLOAT_VALUE     reduce using rule 34 (statement -> scope .)
    INTEGRAL_VALUE  reduce using rule 34 (statement -> scope .)
    RBRACE          reduce using rule 34 (statement -> scope .)


state 57

    (35) statement -> array_assignment . END
    END             shift and go to state 93


state 58

    (36) statement -> scalar_assignment . END
    END             shift and go to state 94


state 59

    (37) statement -> array_declaration_init . END
    END             shift and go to state 95


state 60

    (38) statement -> scalar_declaration_init . END
    END             shift and go to state 96


state 61

    (39) statement -> array_declaration . END
    END             shift and go to state 97


state 62

    (40) statement -> scalar_declaration . END
    END             shift and go to state 98


state 63

    (41) statement -> expression . END
    (72) insertion_statement -> expression . INSERTION expression multi_insertion
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    END             shift and go to state 99
    INSERTION       shift and go to state 100
    OR              shift and go to state 101
    AND             shift and go to state 102


state 64

    (60) return_statement -> RETURN . expression END
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 103
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 65

    (56) if_statement -> IF . LPAREN expression RPAREN scope else_statement
    LPAREN          shift and go to state 104


state 66

    (54) for_statement -> FOR . LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    LPAREN          shift and go to state 105


state 67

    (55) while_statement -> WHILE . LPAREN expression RPAREN scope
    LPAREN          shift and go to state 106


state 68

    (78) comparison_layer -> arithmetic_layer .
    (81) arithmetic_layer -> arithmetic_layer . MINUS term
    (82) arithmetic_layer -> arithmetic_layer . PLUS term
    COMPARATOR      reduce using rule 78 (comparison_layer -> arithmetic_layer .)
    END             reduce using rule 78 (comparison_layer -> arithmetic_layer .)
    INSERTION       reduce using rule 78 (comparison_layer -> arithmetic_layer .)
    OR              reduce using rule 78 (comparison_layer -> arithmetic_layer .)
    AND             reduce using rule 78 (comparison_layer -> arithmetic_layer .)
    RPAREN          reduce using rule 78 (comparison_layer -> arithmetic_layer .)
    COMMA           reduce using rule 78 (comparison_layer -> arithmetic_layer .)
    MINUS           shift and go to state 107
    PLUS            shift and go to state 108


state 69

    (64) array_declaration_init -> DECLARE . ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> DECLARE . ID COLON type ASSIGN expression
    (62) array_declaration -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (61) scalar_declaration -> DECLARE . ID COLON type
    ID              shift and go to state 109


state 70

    (103) value -> INTEGRAL_VALUE .
    DIVISION        reduce using rule 103 (value -> INTEGRAL_VALUE .)
    MULTIPLICATION  reduce using rule 103 (value -> INTEGRAL_VALUE .)
    MINUS           reduce using rule 103 (value -> INTEGRAL_VALUE .)
    PLUS            reduce using rule 103 (value -> INTEGRAL_VALUE .)
    COMPARATOR      reduce using rule 103 (value -> INTEGRAL_VALUE .)
    END             reduce using rule 103 (value -> INTEGRAL_VALUE .)
    INSERTION       reduce using rule 103 (value -> INTEGRAL_VALUE .)
    OR              reduce using rule 103 (value -> INTEGRAL_VALUE .)
    AND             reduce using rule 103 (value -> INTEGRAL_VALUE .)
    RPAREN          reduce using rule 103 (value -> INTEGRAL_VALUE .)
    RSBRACKET       reduce using rule 103 (value -> INTEGRAL_VALUE .)
    COMMA           reduce using rule 103 (value -> INTEGRAL_VALUE .)
    RBRACE          reduce using rule 103 (value -> INTEGRAL_VALUE .)


state 71

    (75) expression -> comparison_layer .
    (79) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 75 (expression -> comparison_layer .)
    INSERTION       reduce using rule 75 (expression -> comparison_layer .)
    OR              reduce using rule 75 (expression -> comparison_layer .)
    AND             reduce using rule 75 (expression -> comparison_layer .)
    RPAREN          reduce using rule 75 (expression -> comparison_layer .)
    COMMA           reduce using rule 75 (expression -> comparison_layer .)
    COMPARATOR      shift and go to state 110


state 72

    (80) arithmetic_layer -> term .
    (84) term -> term . DIVISION factor
    (85) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 80 (arithmetic_layer -> term .)
    PLUS            reduce using rule 80 (arithmetic_layer -> term .)
    COMPARATOR      reduce using rule 80 (arithmetic_layer -> term .)
    END             reduce using rule 80 (arithmetic_layer -> term .)
    INSERTION       reduce using rule 80 (arithmetic_layer -> term .)
    OR              reduce using rule 80 (arithmetic_layer -> term .)
    AND             reduce using rule 80 (arithmetic_layer -> term .)
    RPAREN          reduce using rule 80 (arithmetic_layer -> term .)
    RSBRACKET       reduce using rule 80 (arithmetic_layer -> term .)
    COMMA           reduce using rule 80 (arithmetic_layer -> term .)
    DIVISION        shift and go to state 111
    MULTIPLICATION  shift and go to state 112


state 73

    (83) term -> factor .
    DIVISION        reduce using rule 83 (term -> factor .)
    MULTIPLICATION  reduce using rule 83 (term -> factor .)
    MINUS           reduce using rule 83 (term -> factor .)
    PLUS            reduce using rule 83 (term -> factor .)
    COMPARATOR      reduce using rule 83 (term -> factor .)
    END             reduce using rule 83 (term -> factor .)
    INSERTION       reduce using rule 83 (term -> factor .)
    OR              reduce using rule 83 (term -> factor .)
    AND             reduce using rule 83 (term -> factor .)
    RPAREN          reduce using rule 83 (term -> factor .)
    RSBRACKET       reduce using rule 83 (term -> factor .)
    COMMA           reduce using rule 83 (term -> factor .)


state 74

    (88) factor -> value .
    DIVISION        reduce using rule 88 (factor -> value .)
    MULTIPLICATION  reduce using rule 88 (factor -> value .)
    MINUS           reduce using rule 88 (factor -> value .)
    PLUS            reduce using rule 88 (factor -> value .)
    COMPARATOR      reduce using rule 88 (factor -> value .)
    END             reduce using rule 88 (factor -> value .)
    INSERTION       reduce using rule 88 (factor -> value .)
    OR              reduce using rule 88 (factor -> value .)
    AND             reduce using rule 88 (factor -> value .)
    RPAREN          reduce using rule 88 (factor -> value .)
    RSBRACKET       reduce using rule 88 (factor -> value .)
    COMMA           reduce using rule 88 (factor -> value .)


state 75

    (90) factor -> function_call .
    DIVISION        reduce using rule 90 (factor -> function_call .)
    MULTIPLICATION  reduce using rule 90 (factor -> function_call .)
    MINUS           reduce using rule 90 (factor -> function_call .)
    PLUS            reduce using rule 90 (factor -> function_call .)
    COMPARATOR      reduce using rule 90 (factor -> function_call .)
    END             reduce using rule 90 (factor -> function_call .)
    INSERTION       reduce using rule 90 (factor -> function_call .)
    OR              reduce using rule 90 (factor -> function_call .)
    AND             reduce using rule 90 (factor -> function_call .)
    RPAREN          reduce using rule 90 (factor -> function_call .)
    RSBRACKET       reduce using rule 90 (factor -> function_call .)
    COMMA           reduce using rule 90 (factor -> function_call .)


state 76

    (99) value -> STRING_VALUE .
    DIVISION        reduce using rule 99 (value -> STRING_VALUE .)
    MULTIPLICATION  reduce using rule 99 (value -> STRING_VALUE .)
    MINUS           reduce using rule 99 (value -> STRING_VALUE .)
    PLUS            reduce using rule 99 (value -> STRING_VALUE .)
    COMPARATOR      reduce using rule 99 (value -> STRING_VALUE .)
    END             reduce using rule 99 (value -> STRING_VALUE .)
    INSERTION       reduce using rule 99 (value -> STRING_VALUE .)
    OR              reduce using rule 99 (value -> STRING_VALUE .)
    AND             reduce using rule 99 (value -> STRING_VALUE .)
    RPAREN          reduce using rule 99 (value -> STRING_VALUE .)
    RSBRACKET       reduce using rule 99 (value -> STRING_VALUE .)
    COMMA           reduce using rule 99 (value -> STRING_VALUE .)
    RBRACE          reduce using rule 99 (value -> STRING_VALUE .)


state 77

    (100) value -> CHAR_VALUE .
    DIVISION        reduce using rule 100 (value -> CHAR_VALUE .)
    MULTIPLICATION  reduce using rule 100 (value -> CHAR_VALUE .)
    MINUS           reduce using rule 100 (value -> CHAR_VALUE .)
    PLUS            reduce using rule 100 (value -> CHAR_VALUE .)
    COMPARATOR      reduce using rule 100 (value -> CHAR_VALUE .)
    END             reduce using rule 100 (value -> CHAR_VALUE .)
    INSERTION       reduce using rule 100 (value -> CHAR_VALUE .)
    OR              reduce using rule 100 (value -> CHAR_VALUE .)
    AND             reduce using rule 100 (value -> CHAR_VALUE .)
    RPAREN          reduce using rule 100 (value -> CHAR_VALUE .)
    RSBRACKET       reduce using rule 100 (value -> CHAR_VALUE .)
    COMMA           reduce using rule 100 (value -> CHAR_VALUE .)
    RBRACE          reduce using rule 100 (value -> CHAR_VALUE .)


state 78

    (101) value -> BOOL_VALUE .
    DIVISION        reduce using rule 101 (value -> BOOL_VALUE .)
    MULTIPLICATION  reduce using rule 101 (value -> BOOL_VALUE .)
    MINUS           reduce using rule 101 (value -> BOOL_VALUE .)
    PLUS            reduce using rule 101 (value -> BOOL_VALUE .)
    COMPARATOR      reduce using rule 101 (value -> BOOL_VALUE .)
    END             reduce using rule 101 (value -> BOOL_VALUE .)
    INSERTION       reduce using rule 101 (value -> BOOL_VALUE .)
    OR              reduce using rule 101 (value -> BOOL_VALUE .)
    AND             reduce using rule 101 (value -> BOOL_VALUE .)
    RPAREN          reduce using rule 101 (value -> BOOL_VALUE .)
    RSBRACKET       reduce using rule 101 (value -> BOOL_VALUE .)
    COMMA           reduce using rule 101 (value -> BOOL_VALUE .)
    RBRACE          reduce using rule 101 (value -> BOOL_VALUE .)


state 79

    (102) value -> FLOAT_VALUE .
    DIVISION        reduce using rule 102 (value -> FLOAT_VALUE .)
    MULTIPLICATION  reduce using rule 102 (value -> FLOAT_VALUE .)
    MINUS           reduce using rule 102 (value -> FLOAT_VALUE .)
    PLUS            reduce using rule 102 (value -> FLOAT_VALUE .)
    COMPARATOR      reduce using rule 102 (value -> FLOAT_VALUE .)
    END             reduce using rule 102 (value -> FLOAT_VALUE .)
    INSERTION       reduce using rule 102 (value -> FLOAT_VALUE .)
    OR              reduce using rule 102 (value -> FLOAT_VALUE .)
    AND             reduce using rule 102 (value -> FLOAT_VALUE .)
    RPAREN          reduce using rule 102 (value -> FLOAT_VALUE .)
    RSBRACKET       reduce using rule 102 (value -> FLOAT_VALUE .)
    COMMA           reduce using rule 102 (value -> FLOAT_VALUE .)
    RBRACE          reduce using rule 102 (value -> FLOAT_VALUE .)


state 80

    (12) formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 12 (formal_params -> ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .)


state 81

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 113


state 82

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type multi_formal_params
    RSBRACKET       shift and go to state 114


state 83

    (17) multi_formal_params -> COMMA ID COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 35

    multi_formal_params            shift and go to state 115

state 84

    (71) array_assignment -> ID LSBRACKET . arithmetic_layer RSBRACKET ASSIGN expression
    (87) factor -> ID LSBRACKET . arithmetic_layer RSBRACKET
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    arithmetic_layer               shift and go to state 116
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 85

    (70) scalar_assignment -> ID ASSIGN . expression
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 117
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 86

    (18) function_call -> ID LPAREN . actual_params RPAREN
    (19) actual_params -> .
    (20) actual_params -> . expression multi_actual_params
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RPAREN          reduce using rule 19 (actual_params -> .)
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    actual_params                  shift and go to state 118
    expression                     shift and go to state 119
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 87

    (89) factor -> LPAREN expression . RPAREN
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 120
    OR              shift and go to state 101
    AND             shift and go to state 102


state 88

    (86) factor -> ID .
    (87) factor -> ID . LSBRACKET arithmetic_layer RSBRACKET
    (18) function_call -> ID . LPAREN actual_params RPAREN
    DIVISION        reduce using rule 86 (factor -> ID .)
    MULTIPLICATION  reduce using rule 86 (factor -> ID .)
    MINUS           reduce using rule 86 (factor -> ID .)
    PLUS            reduce using rule 86 (factor -> ID .)
    COMPARATOR      reduce using rule 86 (factor -> ID .)
    RPAREN          reduce using rule 86 (factor -> ID .)
    OR              reduce using rule 86 (factor -> ID .)
    AND             reduce using rule 86 (factor -> ID .)
    END             reduce using rule 86 (factor -> ID .)
    RSBRACKET       reduce using rule 86 (factor -> ID .)
    COMMA           reduce using rule 86 (factor -> ID .)
    INSERTION       reduce using rule 86 (factor -> ID .)
    LSBRACKET       shift and go to state 121
    LPAREN          shift and go to state 86


state 89

    (23) scope -> LBRACE new_scope . statements pop_scope RBRACE
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . insertion_statement END
    (30) statement -> . return_statement
    (31) statement -> . if_statement
    (32) statement -> . for_statement
    (33) statement -> . while_statement
    (34) statement -> . scope
    (35) statement -> . array_assignment END
    (36) statement -> . scalar_assignment END
    (37) statement -> . array_declaration_init END
    (38) statement -> . scalar_declaration_init END
    (39) statement -> . array_declaration END
    (40) statement -> . scalar_declaration END
    (41) statement -> . expression END
    (72) insertion_statement -> . expression INSERTION expression multi_insertion
    (60) return_statement -> . RETURN expression END
    (56) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (54) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (55) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (71) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (70) scalar_assignment -> . ID ASSIGN expression
    (64) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (62) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (61) scalar_declaration -> . DECLARE ID COLON type
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 50
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 66
    WHILE           shift and go to state 67
    LBRACE          shift and go to state 47
    ID              shift and go to state 45
    DECLARE         shift and go to state 69
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    statements                     shift and go to state 122
    statement                      shift and go to state 49
    insertion_statement            shift and go to state 51
    return_statement               shift and go to state 52
    if_statement                   shift and go to state 53
    for_statement                  shift and go to state 54
    while_statement                shift and go to state 55
    scope                          shift and go to state 56
    array_assignment               shift and go to state 57
    scalar_assignment              shift and go to state 58
    array_declaration_init         shift and go to state 59
    scalar_declaration_init        shift and go to state 60
    array_declaration              shift and go to state 61
    scalar_declaration             shift and go to state 62
    expression                     shift and go to state 63
    arithmetic_layer               shift and go to state 68
    comparison_layer               shift and go to state 71
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 90

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope . RBRACE
    RBRACE          shift and go to state 123


state 91

    (27) statements -> statement statements .
    RBRACE          reduce using rule 27 (statements -> statement statements .)


state 92

    (29) statement -> insertion_statement END .
    END             reduce using rule 29 (statement -> insertion_statement END .)
    RETURN          reduce using rule 29 (statement -> insertion_statement END .)
    IF              reduce using rule 29 (statement -> insertion_statement END .)
    FOR             reduce using rule 29 (statement -> insertion_statement END .)
    WHILE           reduce using rule 29 (statement -> insertion_statement END .)
    LBRACE          reduce using rule 29 (statement -> insertion_statement END .)
    ID              reduce using rule 29 (statement -> insertion_statement END .)
    DECLARE         reduce using rule 29 (statement -> insertion_statement END .)
    LPAREN          reduce using rule 29 (statement -> insertion_statement END .)
    STRING_VALUE    reduce using rule 29 (statement -> insertion_statement END .)
    CHAR_VALUE      reduce using rule 29 (statement -> insertion_statement END .)
    BOOL_VALUE      reduce using rule 29 (statement -> insertion_statement END .)
    FLOAT_VALUE     reduce using rule 29 (statement -> insertion_statement END .)
    INTEGRAL_VALUE  reduce using rule 29 (statement -> insertion_statement END .)
    RBRACE          reduce using rule 29 (statement -> insertion_statement END .)


state 93

    (35) statement -> array_assignment END .
    END             reduce using rule 35 (statement -> array_assignment END .)
    RETURN          reduce using rule 35 (statement -> array_assignment END .)
    IF              reduce using rule 35 (statement -> array_assignment END .)
    FOR             reduce using rule 35 (statement -> array_assignment END .)
    WHILE           reduce using rule 35 (statement -> array_assignment END .)
    LBRACE          reduce using rule 35 (statement -> array_assignment END .)
    ID              reduce using rule 35 (statement -> array_assignment END .)
    DECLARE         reduce using rule 35 (statement -> array_assignment END .)
    LPAREN          reduce using rule 35 (statement -> array_assignment END .)
    STRING_VALUE    reduce using rule 35 (statement -> array_assignment END .)
    CHAR_VALUE      reduce using rule 35 (statement -> array_assignment END .)
    BOOL_VALUE      reduce using rule 35 (statement -> array_assignment END .)
    FLOAT_VALUE     reduce using rule 35 (statement -> array_assignment END .)
    INTEGRAL_VALUE  reduce using rule 35 (statement -> array_assignment END .)
    RBRACE          reduce using rule 35 (statement -> array_assignment END .)


state 94

    (36) statement -> scalar_assignment END .
    END             reduce using rule 36 (statement -> scalar_assignment END .)
    RETURN          reduce using rule 36 (statement -> scalar_assignment END .)
    IF              reduce using rule 36 (statement -> scalar_assignment END .)
    FOR             reduce using rule 36 (statement -> scalar_assignment END .)
    WHILE           reduce using rule 36 (statement -> scalar_assignment END .)
    LBRACE          reduce using rule 36 (statement -> scalar_assignment END .)
    ID              reduce using rule 36 (statement -> scalar_assignment END .)
    DECLARE         reduce using rule 36 (statement -> scalar_assignment END .)
    LPAREN          reduce using rule 36 (statement -> scalar_assignment END .)
    STRING_VALUE    reduce using rule 36 (statement -> scalar_assignment END .)
    CHAR_VALUE      reduce using rule 36 (statement -> scalar_assignment END .)
    BOOL_VALUE      reduce using rule 36 (statement -> scalar_assignment END .)
    FLOAT_VALUE     reduce using rule 36 (statement -> scalar_assignment END .)
    INTEGRAL_VALUE  reduce using rule 36 (statement -> scalar_assignment END .)
    RBRACE          reduce using rule 36 (statement -> scalar_assignment END .)


state 95

    (37) statement -> array_declaration_init END .
    END             reduce using rule 37 (statement -> array_declaration_init END .)
    RETURN          reduce using rule 37 (statement -> array_declaration_init END .)
    IF              reduce using rule 37 (statement -> array_declaration_init END .)
    FOR             reduce using rule 37 (statement -> array_declaration_init END .)
    WHILE           reduce using rule 37 (statement -> array_declaration_init END .)
    LBRACE          reduce using rule 37 (statement -> array_declaration_init END .)
    ID              reduce using rule 37 (statement -> array_declaration_init END .)
    DECLARE         reduce using rule 37 (statement -> array_declaration_init END .)
    LPAREN          reduce using rule 37 (statement -> array_declaration_init END .)
    STRING_VALUE    reduce using rule 37 (statement -> array_declaration_init END .)
    CHAR_VALUE      reduce using rule 37 (statement -> array_declaration_init END .)
    BOOL_VALUE      reduce using rule 37 (statement -> array_declaration_init END .)
    FLOAT_VALUE     reduce using rule 37 (statement -> array_declaration_init END .)
    INTEGRAL_VALUE  reduce using rule 37 (statement -> array_declaration_init END .)
    RBRACE          reduce using rule 37 (statement -> array_declaration_init END .)


state 96

    (38) statement -> scalar_declaration_init END .
    END             reduce using rule 38 (statement -> scalar_declaration_init END .)
    RETURN          reduce using rule 38 (statement -> scalar_declaration_init END .)
    IF              reduce using rule 38 (statement -> scalar_declaration_init END .)
    FOR             reduce using rule 38 (statement -> scalar_declaration_init END .)
    WHILE           reduce using rule 38 (statement -> scalar_declaration_init END .)
    LBRACE          reduce using rule 38 (statement -> scalar_declaration_init END .)
    ID              reduce using rule 38 (statement -> scalar_declaration_init END .)
    DECLARE         reduce using rule 38 (statement -> scalar_declaration_init END .)
    LPAREN          reduce using rule 38 (statement -> scalar_declaration_init END .)
    STRING_VALUE    reduce using rule 38 (statement -> scalar_declaration_init END .)
    CHAR_VALUE      reduce using rule 38 (statement -> scalar_declaration_init END .)
    BOOL_VALUE      reduce using rule 38 (statement -> scalar_declaration_init END .)
    FLOAT_VALUE     reduce using rule 38 (statement -> scalar_declaration_init END .)
    INTEGRAL_VALUE  reduce using rule 38 (statement -> scalar_declaration_init END .)
    RBRACE          reduce using rule 38 (statement -> scalar_declaration_init END .)


state 97

    (39) statement -> array_declaration END .
    END             reduce using rule 39 (statement -> array_declaration END .)
    RETURN          reduce using rule 39 (statement -> array_declaration END .)
    IF              reduce using rule 39 (statement -> array_declaration END .)
    FOR             reduce using rule 39 (statement -> array_declaration END .)
    WHILE           reduce using rule 39 (statement -> array_declaration END .)
    LBRACE          reduce using rule 39 (statement -> array_declaration END .)
    ID              reduce using rule 39 (statement -> array_declaration END .)
    DECLARE         reduce using rule 39 (statement -> array_declaration END .)
    LPAREN          reduce using rule 39 (statement -> array_declaration END .)
    STRING_VALUE    reduce using rule 39 (statement -> array_declaration END .)
    CHAR_VALUE      reduce using rule 39 (statement -> array_declaration END .)
    BOOL_VALUE      reduce using rule 39 (statement -> array_declaration END .)
    FLOAT_VALUE     reduce using rule 39 (statement -> array_declaration END .)
    INTEGRAL_VALUE  reduce using rule 39 (statement -> array_declaration END .)
    RBRACE          reduce using rule 39 (statement -> array_declaration END .)


state 98

    (40) statement -> scalar_declaration END .
    END             reduce using rule 40 (statement -> scalar_declaration END .)
    RETURN          reduce using rule 40 (statement -> scalar_declaration END .)
    IF              reduce using rule 40 (statement -> scalar_declaration END .)
    FOR             reduce using rule 40 (statement -> scalar_declaration END .)
    WHILE           reduce using rule 40 (statement -> scalar_declaration END .)
    LBRACE          reduce using rule 40 (statement -> scalar_declaration END .)
    ID              reduce using rule 40 (statement -> scalar_declaration END .)
    DECLARE         reduce using rule 40 (statement -> scalar_declaration END .)
    LPAREN          reduce using rule 40 (statement -> scalar_declaration END .)
    STRING_VALUE    reduce using rule 40 (statement -> scalar_declaration END .)
    CHAR_VALUE      reduce using rule 40 (statement -> scalar_declaration END .)
    BOOL_VALUE      reduce using rule 40 (statement -> scalar_declaration END .)
    FLOAT_VALUE     reduce using rule 40 (statement -> scalar_declaration END .)
    INTEGRAL_VALUE  reduce using rule 40 (statement -> scalar_declaration END .)
    RBRACE          reduce using rule 40 (statement -> scalar_declaration END .)


state 99

    (41) statement -> expression END .
    END             reduce using rule 41 (statement -> expression END .)
    RETURN          reduce using rule 41 (statement -> expression END .)
    IF              reduce using rule 41 (statement -> expression END .)
    FOR             reduce using rule 41 (statement -> expression END .)
    WHILE           reduce using rule 41 (statement -> expression END .)
    LBRACE          reduce using rule 41 (statement -> expression END .)
    ID              reduce using rule 41 (statement -> expression END .)
    DECLARE         reduce using rule 41 (statement -> expression END .)
    LPAREN          reduce using rule 41 (statement -> expression END .)
    STRING_VALUE    reduce using rule 41 (statement -> expression END .)
    CHAR_VALUE      reduce using rule 41 (statement -> expression END .)
    BOOL_VALUE      reduce using rule 41 (statement -> expression END .)
    FLOAT_VALUE     reduce using rule 41 (statement -> expression END .)
    INTEGRAL_VALUE  reduce using rule 41 (statement -> expression END .)
    RBRACE          reduce using rule 41 (statement -> expression END .)


state 100

    (72) insertion_statement -> expression INSERTION . expression multi_insertion
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 124
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 101

    (76) expression -> expression OR . comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    comparison_layer               shift and go to state 125
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 102

    (77) expression -> expression AND . comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    comparison_layer               shift and go to state 126
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 103

    (60) return_statement -> RETURN expression . END
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    END             shift and go to state 127
    OR              shift and go to state 101
    AND             shift and go to state 102


state 104

    (56) if_statement -> IF LPAREN . expression RPAREN scope else_statement
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 128
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 105

    (54) for_statement -> FOR LPAREN . new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (24) new_scope -> .
    ID              reduce using rule 24 (new_scope -> .)
    DECLARE         reduce using rule 24 (new_scope -> .)
    LPAREN          reduce using rule 24 (new_scope -> .)
    STRING_VALUE    reduce using rule 24 (new_scope -> .)
    CHAR_VALUE      reduce using rule 24 (new_scope -> .)
    BOOL_VALUE      reduce using rule 24 (new_scope -> .)
    FLOAT_VALUE     reduce using rule 24 (new_scope -> .)
    INTEGRAL_VALUE  reduce using rule 24 (new_scope -> .)
    END             reduce using rule 24 (new_scope -> .)

    new_scope                      shift and go to state 129

state 106

    (55) while_statement -> WHILE LPAREN . expression RPAREN scope
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 130
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 107

    (81) arithmetic_layer -> arithmetic_layer MINUS . term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    term                           shift and go to state 131
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 108

    (82) arithmetic_layer -> arithmetic_layer PLUS . term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    term                           shift and go to state 132
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 109

    (64) array_declaration_init -> DECLARE ID . LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> DECLARE ID . COLON type ASSIGN expression
    (62) array_declaration -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (61) scalar_declaration -> DECLARE ID . COLON type
    LSBRACKET       shift and go to state 133
    COLON           shift and go to state 134


state 110

    (79) comparison_layer -> comparison_layer COMPARATOR . arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    arithmetic_layer               shift and go to state 135
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 111

    (84) term -> term DIVISION . factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    factor                         shift and go to state 136
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 112

    (85) term -> term MULTIPLICATION . factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    factor                         shift and go to state 137
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 113

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON . type multi_formal_params
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 138

state 114

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type multi_formal_params
    COLON           shift and go to state 139


state 115

    (17) multi_formal_params -> COMMA ID COLON type multi_formal_params .
    RPAREN          reduce using rule 17 (multi_formal_params -> COMMA ID COLON type multi_formal_params .)


state 116

    (71) array_assignment -> ID LSBRACKET arithmetic_layer . RSBRACKET ASSIGN expression
    (87) factor -> ID LSBRACKET arithmetic_layer . RSBRACKET
    (81) arithmetic_layer -> arithmetic_layer . MINUS term
    (82) arithmetic_layer -> arithmetic_layer . PLUS term
    RSBRACKET       shift and go to state 140
    MINUS           shift and go to state 107
    PLUS            shift and go to state 108


state 117

    (70) scalar_assignment -> ID ASSIGN expression .
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    END             reduce using rule 70 (scalar_assignment -> ID ASSIGN expression .)
    RPAREN          reduce using rule 70 (scalar_assignment -> ID ASSIGN expression .)
    OR              shift and go to state 101
    AND             shift and go to state 102


state 118

    (18) function_call -> ID LPAREN actual_params . RPAREN
    RPAREN          shift and go to state 141


state 119

    (20) actual_params -> expression . multi_actual_params
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    (21) multi_actual_params -> .
    (22) multi_actual_params -> . COMMA expression multi_actual_params
    OR              shift and go to state 101
    AND             shift and go to state 102
    RPAREN          reduce using rule 21 (multi_actual_params -> .)
    COMMA           shift and go to state 143

    multi_actual_params            shift and go to state 142

state 120

    (89) factor -> LPAREN expression RPAREN .
    DIVISION        reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    MULTIPLICATION  reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    COMPARATOR      reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    INSERTION       reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    RSBRACKET       reduce using rule 89 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 89 (factor -> LPAREN expression RPAREN .)


state 121

    (87) factor -> ID LSBRACKET . arithmetic_layer RSBRACKET
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    arithmetic_layer               shift and go to state 144
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 122

    (23) scope -> LBRACE new_scope statements . pop_scope RBRACE
    (25) pop_scope -> .
    RBRACE          reduce using rule 25 (pop_scope -> .)

    pop_scope                      shift and go to state 145

state 123

    (9) function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .
    USE             reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)
    INCLUDE         reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)
    ID              reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)
    $end            reduce using rule 9 (function -> ID LPAREN new_scope formal_params RPAREN COLON type LBRACE statements pop_scope RBRACE .)


state 124

    (72) insertion_statement -> expression INSERTION expression . multi_insertion
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    (73) multi_insertion -> .
    (74) multi_insertion -> . INSERTION expression multi_insertion
    OR              shift and go to state 101
    AND             shift and go to state 102
    END             reduce using rule 73 (multi_insertion -> .)
    INSERTION       shift and go to state 146

    multi_insertion                shift and go to state 147

state 125

    (76) expression -> expression OR comparison_layer .
    (79) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 76 (expression -> expression OR comparison_layer .)
    INSERTION       reduce using rule 76 (expression -> expression OR comparison_layer .)
    OR              reduce using rule 76 (expression -> expression OR comparison_layer .)
    AND             reduce using rule 76 (expression -> expression OR comparison_layer .)
    RPAREN          reduce using rule 76 (expression -> expression OR comparison_layer .)
    COMMA           reduce using rule 76 (expression -> expression OR comparison_layer .)
    COMPARATOR      shift and go to state 110


state 126

    (77) expression -> expression AND comparison_layer .
    (79) comparison_layer -> comparison_layer . COMPARATOR arithmetic_layer
    END             reduce using rule 77 (expression -> expression AND comparison_layer .)
    INSERTION       reduce using rule 77 (expression -> expression AND comparison_layer .)
    OR              reduce using rule 77 (expression -> expression AND comparison_layer .)
    AND             reduce using rule 77 (expression -> expression AND comparison_layer .)
    RPAREN          reduce using rule 77 (expression -> expression AND comparison_layer .)
    COMMA           reduce using rule 77 (expression -> expression AND comparison_layer .)
    COMPARATOR      shift and go to state 110


state 127

    (60) return_statement -> RETURN expression END .
    END             reduce using rule 60 (return_statement -> RETURN expression END .)
    RETURN          reduce using rule 60 (return_statement -> RETURN expression END .)
    IF              reduce using rule 60 (return_statement -> RETURN expression END .)
    FOR             reduce using rule 60 (return_statement -> RETURN expression END .)
    WHILE           reduce using rule 60 (return_statement -> RETURN expression END .)
    LBRACE          reduce using rule 60 (return_statement -> RETURN expression END .)
    ID              reduce using rule 60 (return_statement -> RETURN expression END .)
    DECLARE         reduce using rule 60 (return_statement -> RETURN expression END .)
    LPAREN          reduce using rule 60 (return_statement -> RETURN expression END .)
    STRING_VALUE    reduce using rule 60 (return_statement -> RETURN expression END .)
    CHAR_VALUE      reduce using rule 60 (return_statement -> RETURN expression END .)
    BOOL_VALUE      reduce using rule 60 (return_statement -> RETURN expression END .)
    FLOAT_VALUE     reduce using rule 60 (return_statement -> RETURN expression END .)
    INTEGRAL_VALUE  reduce using rule 60 (return_statement -> RETURN expression END .)
    RBRACE          reduce using rule 60 (return_statement -> RETURN expression END .)


state 128

    (56) if_statement -> IF LPAREN expression . RPAREN scope else_statement
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 148
    OR              shift and go to state 101
    AND             shift and go to state 102


state 129

    (54) for_statement -> FOR LPAREN new_scope . for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (42) for_init -> .
    (43) for_init -> . expression
    (44) for_init -> . array_assignment
    (45) for_init -> . array_declaration_init
    (46) for_init -> . scalar_assignment
    (47) for_init -> . scalar_declaration_init
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (71) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (64) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (70) scalar_assignment -> . ID ASSIGN expression
    (63) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    END             reduce using rule 42 (for_init -> .)
    ID              shift and go to state 45
    DECLARE         shift and go to state 155
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    for_init                       shift and go to state 149
    expression                     shift and go to state 150
    array_assignment               shift and go to state 151
    array_declaration_init         shift and go to state 152
    scalar_assignment              shift and go to state 153
    scalar_declaration_init        shift and go to state 154
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 130

    (55) while_statement -> WHILE LPAREN expression . RPAREN scope
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    RPAREN          shift and go to state 156
    OR              shift and go to state 101
    AND             shift and go to state 102


state 131

    (81) arithmetic_layer -> arithmetic_layer MINUS term .
    (84) term -> term . DIVISION factor
    (85) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    PLUS            reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    COMPARATOR      reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    END             reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    INSERTION       reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    OR              reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    AND             reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    RPAREN          reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    RSBRACKET       reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    COMMA           reduce using rule 81 (arithmetic_layer -> arithmetic_layer MINUS term .)
    DIVISION        shift and go to state 111
    MULTIPLICATION  shift and go to state 112


state 132

    (82) arithmetic_layer -> arithmetic_layer PLUS term .
    (84) term -> term . DIVISION factor
    (85) term -> term . MULTIPLICATION factor
    MINUS           reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    PLUS            reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    COMPARATOR      reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    END             reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    INSERTION       reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    OR              reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    AND             reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    RPAREN          reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    RSBRACKET       reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    COMMA           reduce using rule 82 (arithmetic_layer -> arithmetic_layer PLUS term .)
    DIVISION        shift and go to state 111
    MULTIPLICATION  shift and go to state 112


state 133

    (64) array_declaration_init -> DECLARE ID LSBRACKET . RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (62) array_declaration -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type
    RSBRACKET       shift and go to state 157
    INTEGRAL_VALUE  shift and go to state 158


state 134

    (63) scalar_declaration_init -> DECLARE ID COLON . type ASSIGN expression
    (61) scalar_declaration -> DECLARE ID COLON . type
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 159

state 135

    (79) comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .
    (81) arithmetic_layer -> arithmetic_layer . MINUS term
    (82) arithmetic_layer -> arithmetic_layer . PLUS term
    COMPARATOR      reduce using rule 79 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    END             reduce using rule 79 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    INSERTION       reduce using rule 79 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    OR              reduce using rule 79 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    AND             reduce using rule 79 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    RPAREN          reduce using rule 79 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    COMMA           reduce using rule 79 (comparison_layer -> comparison_layer COMPARATOR arithmetic_layer .)
    MINUS           shift and go to state 107
    PLUS            shift and go to state 108


state 136

    (84) term -> term DIVISION factor .
    DIVISION        reduce using rule 84 (term -> term DIVISION factor .)
    MULTIPLICATION  reduce using rule 84 (term -> term DIVISION factor .)
    MINUS           reduce using rule 84 (term -> term DIVISION factor .)
    PLUS            reduce using rule 84 (term -> term DIVISION factor .)
    COMPARATOR      reduce using rule 84 (term -> term DIVISION factor .)
    END             reduce using rule 84 (term -> term DIVISION factor .)
    INSERTION       reduce using rule 84 (term -> term DIVISION factor .)
    OR              reduce using rule 84 (term -> term DIVISION factor .)
    AND             reduce using rule 84 (term -> term DIVISION factor .)
    RPAREN          reduce using rule 84 (term -> term DIVISION factor .)
    RSBRACKET       reduce using rule 84 (term -> term DIVISION factor .)
    COMMA           reduce using rule 84 (term -> term DIVISION factor .)


state 137

    (85) term -> term MULTIPLICATION factor .
    DIVISION        reduce using rule 85 (term -> term MULTIPLICATION factor .)
    MULTIPLICATION  reduce using rule 85 (term -> term MULTIPLICATION factor .)
    MINUS           reduce using rule 85 (term -> term MULTIPLICATION factor .)
    PLUS            reduce using rule 85 (term -> term MULTIPLICATION factor .)
    COMPARATOR      reduce using rule 85 (term -> term MULTIPLICATION factor .)
    END             reduce using rule 85 (term -> term MULTIPLICATION factor .)
    INSERTION       reduce using rule 85 (term -> term MULTIPLICATION factor .)
    OR              reduce using rule 85 (term -> term MULTIPLICATION factor .)
    AND             reduce using rule 85 (term -> term MULTIPLICATION factor .)
    RPAREN          reduce using rule 85 (term -> term MULTIPLICATION factor .)
    RSBRACKET       reduce using rule 85 (term -> term MULTIPLICATION factor .)
    COMMA           reduce using rule 85 (term -> term MULTIPLICATION factor .)


state 138

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 35

    multi_formal_params            shift and go to state 160

state 139

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type multi_formal_params
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 161

state 140

    (71) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET . ASSIGN expression
    (87) factor -> ID LSBRACKET arithmetic_layer RSBRACKET .
    ASSIGN          shift and go to state 162
    DIVISION        reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MULTIPLICATION  reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MINUS           reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    PLUS            reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMPARATOR      reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    END             reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    INSERTION       reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    OR              reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    AND             reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RPAREN          reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)


state 141

    (18) function_call -> ID LPAREN actual_params RPAREN .
    DIVISION        reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    MULTIPLICATION  reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    MINUS           reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    PLUS            reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    COMPARATOR      reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    END             reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    INSERTION       reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    OR              reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    AND             reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    RPAREN          reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    RSBRACKET       reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)
    COMMA           reduce using rule 18 (function_call -> ID LPAREN actual_params RPAREN .)


state 142

    (20) actual_params -> expression multi_actual_params .
    RPAREN          reduce using rule 20 (actual_params -> expression multi_actual_params .)


state 143

    (22) multi_actual_params -> COMMA . expression multi_actual_params
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 163
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 144

    (87) factor -> ID LSBRACKET arithmetic_layer . RSBRACKET
    (81) arithmetic_layer -> arithmetic_layer . MINUS term
    (82) arithmetic_layer -> arithmetic_layer . PLUS term
    RSBRACKET       shift and go to state 164
    MINUS           shift and go to state 107
    PLUS            shift and go to state 108


state 145

    (23) scope -> LBRACE new_scope statements pop_scope . RBRACE
    RBRACE          shift and go to state 165


state 146

    (74) multi_insertion -> INSERTION . expression multi_insertion
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 166
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 147

    (72) insertion_statement -> expression INSERTION expression multi_insertion .
    END             reduce using rule 72 (insertion_statement -> expression INSERTION expression multi_insertion .)


state 148

    (56) if_statement -> IF LPAREN expression RPAREN . scope else_statement
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 47

    scope                          shift and go to state 167

state 149

    (54) for_statement -> FOR LPAREN new_scope for_init . END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    END             shift and go to state 168


state 150

    (43) for_init -> expression .
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    END             reduce using rule 43 (for_init -> expression .)
    OR              shift and go to state 101
    AND             shift and go to state 102


state 151

    (44) for_init -> array_assignment .
    END             reduce using rule 44 (for_init -> array_assignment .)


state 152

    (45) for_init -> array_declaration_init .
    END             reduce using rule 45 (for_init -> array_declaration_init .)


state 153

    (46) for_init -> scalar_assignment .
    END             reduce using rule 46 (for_init -> scalar_assignment .)


state 154

    (47) for_init -> scalar_declaration_init .
    END             reduce using rule 47 (for_init -> scalar_declaration_init .)


state 155

    (64) array_declaration_init -> DECLARE . ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> DECLARE . ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> DECLARE . ID COLON type ASSIGN expression
    ID              shift and go to state 169


state 156

    (55) while_statement -> WHILE LPAREN expression RPAREN . scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    LBRACE          shift and go to state 47

    scope                          shift and go to state 170

state 157

    (64) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET . COLON type ASSIGN array_init
    COLON           shift and go to state 171


state 158

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type ASSIGN array_init
    (62) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type
    RSBRACKET       shift and go to state 172


state 159

    (63) scalar_declaration_init -> DECLARE ID COLON type . ASSIGN expression
    (61) scalar_declaration -> DECLARE ID COLON type .
    ASSIGN          shift and go to state 173
    END             reduce using rule 61 (scalar_declaration -> DECLARE ID COLON type .)


state 160

    (15) multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 15 (multi_formal_params -> COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params .)


state 161

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . multi_formal_params
    (14) multi_formal_params -> .
    (15) multi_formal_params -> . COMMA ID LSBRACKET RSBRACKET COLON type multi_formal_params
    (16) multi_formal_params -> . COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params
    (17) multi_formal_params -> . COMMA ID COLON type multi_formal_params
    RPAREN          reduce using rule 14 (multi_formal_params -> .)
    COMMA           shift and go to state 35

    multi_formal_params            shift and go to state 174

state 162

    (71) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN . expression
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    arithmetic_layer               shift and go to state 68
    expression                     shift and go to state 175
    comparison_layer               shift and go to state 71
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 163

    (22) multi_actual_params -> COMMA expression . multi_actual_params
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    (21) multi_actual_params -> .
    (22) multi_actual_params -> . COMMA expression multi_actual_params
    OR              shift and go to state 101
    AND             shift and go to state 102
    RPAREN          reduce using rule 21 (multi_actual_params -> .)
    COMMA           shift and go to state 143

    multi_actual_params            shift and go to state 176

state 164

    (87) factor -> ID LSBRACKET arithmetic_layer RSBRACKET .
    DIVISION        reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MULTIPLICATION  reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    MINUS           reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    PLUS            reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMPARATOR      reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RPAREN          reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    OR              reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    AND             reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    END             reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    RSBRACKET       reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    COMMA           reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)
    INSERTION       reduce using rule 87 (factor -> ID LSBRACKET arithmetic_layer RSBRACKET .)


state 165

    (23) scope -> LBRACE new_scope statements pop_scope RBRACE .
    END             reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    RETURN          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    IF              reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    FOR             reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    WHILE           reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    LBRACE          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    ID              reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    DECLARE         reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    LPAREN          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    STRING_VALUE    reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    CHAR_VALUE      reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    BOOL_VALUE      reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    FLOAT_VALUE     reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    INTEGRAL_VALUE  reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    RBRACE          reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)
    ELSE            reduce using rule 23 (scope -> LBRACE new_scope statements pop_scope RBRACE .)


state 166

    (74) multi_insertion -> INSERTION expression . multi_insertion
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    (73) multi_insertion -> .
    (74) multi_insertion -> . INSERTION expression multi_insertion
    OR              shift and go to state 101
    AND             shift and go to state 102
    END             reduce using rule 73 (multi_insertion -> .)
    INSERTION       shift and go to state 146

    multi_insertion                shift and go to state 177

state 167

    (56) if_statement -> IF LPAREN expression RPAREN scope . else_statement
    (57) else_statement -> .
    (58) else_statement -> . ELSE if_statement
    (59) else_statement -> . ELSE scope
    END             reduce using rule 57 (else_statement -> .)
    RETURN          reduce using rule 57 (else_statement -> .)
    IF              reduce using rule 57 (else_statement -> .)
    FOR             reduce using rule 57 (else_statement -> .)
    WHILE           reduce using rule 57 (else_statement -> .)
    LBRACE          reduce using rule 57 (else_statement -> .)
    ID              reduce using rule 57 (else_statement -> .)
    DECLARE         reduce using rule 57 (else_statement -> .)
    LPAREN          reduce using rule 57 (else_statement -> .)
    STRING_VALUE    reduce using rule 57 (else_statement -> .)
    CHAR_VALUE      reduce using rule 57 (else_statement -> .)
    BOOL_VALUE      reduce using rule 57 (else_statement -> .)
    FLOAT_VALUE     reduce using rule 57 (else_statement -> .)
    INTEGRAL_VALUE  reduce using rule 57 (else_statement -> .)
    RBRACE          reduce using rule 57 (else_statement -> .)
    ELSE            shift and go to state 179

    else_statement                 shift and go to state 178

state 168

    (54) for_statement -> FOR LPAREN new_scope for_init END . for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (48) for_condition -> .
    (49) for_condition -> . expression
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    END             reduce using rule 48 (for_condition -> .)
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    for_condition                  shift and go to state 180
    expression                     shift and go to state 181
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 169

    (64) array_declaration_init -> DECLARE ID . LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> DECLARE ID . LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> DECLARE ID . COLON type ASSIGN expression
    LSBRACKET       shift and go to state 182
    COLON           shift and go to state 183


state 170

    (55) while_statement -> WHILE LPAREN expression RPAREN scope .
    END             reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    RETURN          reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    IF              reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    FOR             reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    WHILE           reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    LBRACE          reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    ID              reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    DECLARE         reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    LPAREN          reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    STRING_VALUE    reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    CHAR_VALUE      reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    BOOL_VALUE      reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    FLOAT_VALUE     reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    INTEGRAL_VALUE  reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)
    RBRACE          reduce using rule 55 (while_statement -> WHILE LPAREN expression RPAREN scope .)


state 171

    (64) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON . type ASSIGN array_init
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 184

state 172

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type ASSIGN array_init
    (62) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type
    COLON           shift and go to state 185


state 173

    (63) scalar_declaration_init -> DECLARE ID COLON type ASSIGN . expression
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    ID              shift and go to state 88
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    expression                     shift and go to state 186
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 174

    (16) multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .
    RPAREN          reduce using rule 16 (multi_formal_params -> COMMA ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type multi_formal_params .)


state 175

    (71) array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    END             reduce using rule 71 (array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .)
    RPAREN          reduce using rule 71 (array_assignment -> ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression .)
    OR              shift and go to state 101
    AND             shift and go to state 102


state 176

    (22) multi_actual_params -> COMMA expression multi_actual_params .
    RPAREN          reduce using rule 22 (multi_actual_params -> COMMA expression multi_actual_params .)


state 177

    (74) multi_insertion -> INSERTION expression multi_insertion .
    END             reduce using rule 74 (multi_insertion -> INSERTION expression multi_insertion .)


state 178

    (56) if_statement -> IF LPAREN expression RPAREN scope else_statement .
    END             reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    RETURN          reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    IF              reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    FOR             reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    WHILE           reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    LBRACE          reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    ID              reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    DECLARE         reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    LPAREN          reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    STRING_VALUE    reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    CHAR_VALUE      reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    BOOL_VALUE      reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    FLOAT_VALUE     reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    INTEGRAL_VALUE  reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)
    RBRACE          reduce using rule 56 (if_statement -> IF LPAREN expression RPAREN scope else_statement .)


state 179

    (58) else_statement -> ELSE . if_statement
    (59) else_statement -> ELSE . scope
    (56) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    IF              shift and go to state 65
    LBRACE          shift and go to state 47

    if_statement                   shift and go to state 187
    scope                          shift and go to state 188

state 180

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition . END for_increment RPAREN LBRACE statements pop_scope RBRACE
    END             shift and go to state 189


state 181

    (49) for_condition -> expression .
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    END             reduce using rule 49 (for_condition -> expression .)
    OR              shift and go to state 101
    AND             shift and go to state 102


state 182

    (64) array_declaration_init -> DECLARE ID LSBRACKET . RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> DECLARE ID LSBRACKET . INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    RSBRACKET       shift and go to state 157
    INTEGRAL_VALUE  shift and go to state 190


state 183

    (63) scalar_declaration_init -> DECLARE ID COLON . type ASSIGN expression
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 191

state 184

    (64) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type . ASSIGN array_init
    ASSIGN          shift and go to state 192


state 185

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type ASSIGN array_init
    (62) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 193

state 186

    (63) scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression .
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    END             reduce using rule 63 (scalar_declaration_init -> DECLARE ID COLON type ASSIGN expression .)
    OR              shift and go to state 101
    AND             shift and go to state 102


state 187

    (58) else_statement -> ELSE if_statement .
    END             reduce using rule 58 (else_statement -> ELSE if_statement .)
    RETURN          reduce using rule 58 (else_statement -> ELSE if_statement .)
    IF              reduce using rule 58 (else_statement -> ELSE if_statement .)
    FOR             reduce using rule 58 (else_statement -> ELSE if_statement .)
    WHILE           reduce using rule 58 (else_statement -> ELSE if_statement .)
    LBRACE          reduce using rule 58 (else_statement -> ELSE if_statement .)
    ID              reduce using rule 58 (else_statement -> ELSE if_statement .)
    DECLARE         reduce using rule 58 (else_statement -> ELSE if_statement .)
    LPAREN          reduce using rule 58 (else_statement -> ELSE if_statement .)
    STRING_VALUE    reduce using rule 58 (else_statement -> ELSE if_statement .)
    CHAR_VALUE      reduce using rule 58 (else_statement -> ELSE if_statement .)
    BOOL_VALUE      reduce using rule 58 (else_statement -> ELSE if_statement .)
    FLOAT_VALUE     reduce using rule 58 (else_statement -> ELSE if_statement .)
    INTEGRAL_VALUE  reduce using rule 58 (else_statement -> ELSE if_statement .)
    RBRACE          reduce using rule 58 (else_statement -> ELSE if_statement .)


state 188

    (59) else_statement -> ELSE scope .
    END             reduce using rule 59 (else_statement -> ELSE scope .)
    RETURN          reduce using rule 59 (else_statement -> ELSE scope .)
    IF              reduce using rule 59 (else_statement -> ELSE scope .)
    FOR             reduce using rule 59 (else_statement -> ELSE scope .)
    WHILE           reduce using rule 59 (else_statement -> ELSE scope .)
    LBRACE          reduce using rule 59 (else_statement -> ELSE scope .)
    ID              reduce using rule 59 (else_statement -> ELSE scope .)
    DECLARE         reduce using rule 59 (else_statement -> ELSE scope .)
    LPAREN          reduce using rule 59 (else_statement -> ELSE scope .)
    STRING_VALUE    reduce using rule 59 (else_statement -> ELSE scope .)
    CHAR_VALUE      reduce using rule 59 (else_statement -> ELSE scope .)
    BOOL_VALUE      reduce using rule 59 (else_statement -> ELSE scope .)
    FLOAT_VALUE     reduce using rule 59 (else_statement -> ELSE scope .)
    INTEGRAL_VALUE  reduce using rule 59 (else_statement -> ELSE scope .)
    RBRACE          reduce using rule 59 (else_statement -> ELSE scope .)


state 189

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition END . for_increment RPAREN LBRACE statements pop_scope RBRACE
    (50) for_increment -> .
    (51) for_increment -> . expression
    (52) for_increment -> . array_assignment
    (53) for_increment -> . scalar_assignment
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (71) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (70) scalar_assignment -> . ID ASSIGN expression
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RPAREN          reduce using rule 50 (for_increment -> .)
    ID              shift and go to state 45
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    for_increment                  shift and go to state 194
    expression                     shift and go to state 195
    array_assignment               shift and go to state 196
    scalar_assignment              shift and go to state 197
    comparison_layer               shift and go to state 71
    arithmetic_layer               shift and go to state 68
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 190

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE . RSBRACKET COLON type ASSIGN array_init
    RSBRACKET       shift and go to state 198


state 191

    (63) scalar_declaration_init -> DECLARE ID COLON type . ASSIGN expression
    ASSIGN          shift and go to state 173


state 192

    (64) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN . array_init
    (66) array_init -> . LBRACE value multi_array_init RBRACE
    (67) array_init -> . STRING_VALUE
    LBRACE          shift and go to state 200
    STRING_VALUE    shift and go to state 201

    array_init                     shift and go to state 199

state 193

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . ASSIGN array_init
    (62) array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type .
    ASSIGN          shift and go to state 202
    END             reduce using rule 62 (array_declaration -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type .)


state 194

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment . RPAREN LBRACE statements pop_scope RBRACE
    RPAREN          shift and go to state 203


state 195

    (51) for_increment -> expression .
    (76) expression -> expression . OR comparison_layer
    (77) expression -> expression . AND comparison_layer
    RPAREN          reduce using rule 51 (for_increment -> expression .)
    OR              shift and go to state 101
    AND             shift and go to state 102


state 196

    (52) for_increment -> array_assignment .
    RPAREN          reduce using rule 52 (for_increment -> array_assignment .)


state 197

    (53) for_increment -> scalar_assignment .
    RPAREN          reduce using rule 53 (for_increment -> scalar_assignment .)


state 198

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET . COLON type ASSIGN array_init
    COLON           shift and go to state 204


state 199

    (64) array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init .
    END             reduce using rule 64 (array_declaration_init -> DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init .)


state 200

    (66) array_init -> LBRACE . value multi_array_init RBRACE
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    value                          shift and go to state 205

state 201

    (67) array_init -> STRING_VALUE .
    END             reduce using rule 67 (array_init -> STRING_VALUE .)


state 202

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN . array_init
    (66) array_init -> . LBRACE value multi_array_init RBRACE
    (67) array_init -> . STRING_VALUE
    LBRACE          shift and go to state 200
    STRING_VALUE    shift and go to state 201

    array_init                     shift and go to state 206

state 203

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN . LBRACE statements pop_scope RBRACE
    LBRACE          shift and go to state 207


state 204

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON . type ASSIGN array_init
    (91) type -> . ID
    (92) type -> . ABYSS_TYPE
    (93) type -> . BOOL_TYPE
    (94) type -> . STRING_TYPE
    (95) type -> . CHAR_TYPE
    (96) type -> . FLOAT_TYPE
    (97) type -> . UNSIGNED_TYPE
    (98) type -> . SIGNED_TYPE
    ID              shift and go to state 22
    ABYSS_TYPE      shift and go to state 24
    BOOL_TYPE       shift and go to state 25
    STRING_TYPE     shift and go to state 26
    CHAR_TYPE       shift and go to state 27
    FLOAT_TYPE      shift and go to state 28
    UNSIGNED_TYPE   shift and go to state 29
    SIGNED_TYPE     shift and go to state 30

    type                           shift and go to state 208

state 205

    (66) array_init -> LBRACE value . multi_array_init RBRACE
    (68) multi_array_init -> .
    (69) multi_array_init -> . COMMA value multi_array_init
    RBRACE          reduce using rule 68 (multi_array_init -> .)
    COMMA           shift and go to state 210

    multi_array_init               shift and go to state 209

state 206

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init .
    END             reduce using rule 65 (array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init .)


state 207

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE . statements pop_scope RBRACE
    (26) statements -> .
    (27) statements -> . statement statements
    (28) statement -> . END
    (29) statement -> . insertion_statement END
    (30) statement -> . return_statement
    (31) statement -> . if_statement
    (32) statement -> . for_statement
    (33) statement -> . while_statement
    (34) statement -> . scope
    (35) statement -> . array_assignment END
    (36) statement -> . scalar_assignment END
    (37) statement -> . array_declaration_init END
    (38) statement -> . scalar_declaration_init END
    (39) statement -> . array_declaration END
    (40) statement -> . scalar_declaration END
    (41) statement -> . expression END
    (72) insertion_statement -> . expression INSERTION expression multi_insertion
    (60) return_statement -> . RETURN expression END
    (56) if_statement -> . IF LPAREN expression RPAREN scope else_statement
    (54) for_statement -> . FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE
    (55) while_statement -> . WHILE LPAREN expression RPAREN scope
    (23) scope -> . LBRACE new_scope statements pop_scope RBRACE
    (71) array_assignment -> . ID LSBRACKET arithmetic_layer RSBRACKET ASSIGN expression
    (70) scalar_assignment -> . ID ASSIGN expression
    (64) array_declaration_init -> . DECLARE ID LSBRACKET RSBRACKET COLON type ASSIGN array_init
    (65) array_declaration_init -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type ASSIGN array_init
    (63) scalar_declaration_init -> . DECLARE ID COLON type ASSIGN expression
    (62) array_declaration -> . DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type
    (61) scalar_declaration -> . DECLARE ID COLON type
    (75) expression -> . comparison_layer
    (76) expression -> . expression OR comparison_layer
    (77) expression -> . expression AND comparison_layer
    (78) comparison_layer -> . arithmetic_layer
    (79) comparison_layer -> . comparison_layer COMPARATOR arithmetic_layer
    (80) arithmetic_layer -> . term
    (81) arithmetic_layer -> . arithmetic_layer MINUS term
    (82) arithmetic_layer -> . arithmetic_layer PLUS term
    (83) term -> . factor
    (84) term -> . term DIVISION factor
    (85) term -> . term MULTIPLICATION factor
    (86) factor -> . ID
    (87) factor -> . ID LSBRACKET arithmetic_layer RSBRACKET
    (88) factor -> . value
    (89) factor -> . LPAREN expression RPAREN
    (90) factor -> . function_call
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    (18) function_call -> . ID LPAREN actual_params RPAREN
    RBRACE          reduce using rule 26 (statements -> .)
    END             shift and go to state 50
    RETURN          shift and go to state 64
    IF              shift and go to state 65
    FOR             shift and go to state 66
    WHILE           shift and go to state 67
    LBRACE          shift and go to state 47
    ID              shift and go to state 45
    DECLARE         shift and go to state 69
    LPAREN          shift and go to state 46
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    statements                     shift and go to state 211
    statement                      shift and go to state 49
    insertion_statement            shift and go to state 51
    return_statement               shift and go to state 52
    if_statement                   shift and go to state 53
    for_statement                  shift and go to state 54
    while_statement                shift and go to state 55
    scope                          shift and go to state 56
    array_assignment               shift and go to state 57
    scalar_assignment              shift and go to state 58
    array_declaration_init         shift and go to state 59
    scalar_declaration_init        shift and go to state 60
    array_declaration              shift and go to state 61
    scalar_declaration             shift and go to state 62
    expression                     shift and go to state 63
    arithmetic_layer               shift and go to state 68
    comparison_layer               shift and go to state 71
    term                           shift and go to state 72
    factor                         shift and go to state 73
    value                          shift and go to state 74
    function_call                  shift and go to state 75

state 208

    (65) array_declaration_init -> DECLARE ID LSBRACKET INTEGRAL_VALUE RSBRACKET COLON type . ASSIGN array_init
    ASSIGN          shift and go to state 202


state 209

    (66) array_init -> LBRACE value multi_array_init . RBRACE
    RBRACE          shift and go to state 212


state 210

    (69) multi_array_init -> COMMA . value multi_array_init
    (99) value -> . STRING_VALUE
    (100) value -> . CHAR_VALUE
    (101) value -> . BOOL_VALUE
    (102) value -> . FLOAT_VALUE
    (103) value -> . INTEGRAL_VALUE
    STRING_VALUE    shift and go to state 76
    CHAR_VALUE      shift and go to state 77
    BOOL_VALUE      shift and go to state 78
    FLOAT_VALUE     shift and go to state 79
    INTEGRAL_VALUE  shift and go to state 70

    value                          shift and go to state 213

state 211

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements . pop_scope RBRACE
    (25) pop_scope -> .
    RBRACE          reduce using rule 25 (pop_scope -> .)

    pop_scope                      shift and go to state 214

state 212

    (66) array_init -> LBRACE value multi_array_init RBRACE .
    END             reduce using rule 66 (array_init -> LBRACE value multi_array_init RBRACE .)


state 213

    (69) multi_array_init -> COMMA value . multi_array_init
    (68) multi_array_init -> .
    (69) multi_array_init -> . COMMA value multi_array_init
    RBRACE          reduce using rule 68 (multi_array_init -> .)
    COMMA           shift and go to state 210

    multi_array_init               shift and go to state 215

state 214

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope . RBRACE
    RBRACE          shift and go to state 216


state 215

    (69) multi_array_init -> COMMA value multi_array_init .
    RBRACE          reduce using rule 69 (multi_array_init -> COMMA value multi_array_init .)


state 216

    (54) for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .
    END             reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    RETURN          reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    IF              reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    FOR             reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    WHILE           reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    LBRACE          reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    ID              reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    DECLARE         reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    LPAREN          reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    STRING_VALUE    reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    CHAR_VALUE      reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    BOOL_VALUE      reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    FLOAT_VALUE     reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    INTEGRAL_VALUE  reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
    RBRACE          reduce using rule 54 (for_statement -> FOR LPAREN new_scope for_init END for_condition END for_increment RPAREN LBRACE statements pop_scope RBRACE .)
